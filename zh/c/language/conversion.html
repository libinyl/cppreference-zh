<!DOCTYPE html>
<html lang="zh" dir="ltr" class="client-nojs">
<head>
<title>隐式转换</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../../../common/favicon.ico">
<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-css:7:15cea3ec788a65b5187d4018eed543bf */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"c/language/conversion","wgTitle":"c/language/conversion","wgCurRevisionId":51952,"wgArticleId":7944,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Todo with reason"],"wgBreakFrames":false,"wgPageContentLanguage":"zh","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"zh","wgMonthNames":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgMonthNamesShort":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgRelevantPageName":"c/language/conversion","wgUserVariant":"zh","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"zh","language":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-MathJax":1,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-js:7:258d7cd6aa9aa67dee25e01fb6a9e505 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #0000dd;}
.c.source-c .kw2 {color: #0000ff;}
.c.source-c .kw3 {color: #0000dd;}
.c.source-c .kw4 {color: #0000ff;}
.c.source-c .co1 {color: #909090;}
.c.source-c .co2 {color: #339900;}
.c.source-c .coMULTI {color: #ff0000; font-style: italic;}
.c.source-c .es0 {color: #008000; font-weight: bold;}
.c.source-c .es1 {color: #008000; font-weight: bold;}
.c.source-c .es2 {color: #008000; font-weight: bold;}
.c.source-c .es3 {color: #008000; font-weight: bold;}
.c.source-c .es4 {color: #008000; font-weight: bold;}
.c.source-c .es5 {color: #008000; font-weight: bold;}
.c.source-c .br0 {color: #008000;}
.c.source-c .sy0 {color: #008000;}
.c.source-c .sy1 {color: #000080;}
.c.source-c .sy2 {color: #000040;}
.c.source-c .sy3 {color: #000040;}
.c.source-c .sy4 {color: #008080;}
.c.source-c .st0 {color: #008000;}
.c.source-c .nu0 {color: #000080;}
.c.source-c .nu6 {color:#000080;}
.c.source-c .nu8 {color:#000080;}
.c.source-c .nu12 {color:#000080;}
.c.source-c .nu16 {color:#000080;}
.c.source-c .nu17 {color:#000080;}
.c.source-c .nu18 {color:#000080;}
.c.source-c .nu19 {color:#000080;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-c_language_conversion skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
<div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<h1 id="firstHeading" class="firstHeading">隐式转换</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">来自cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../c.html" title="c">c</a>‎ | <a href="../language.html" title="c/language">language</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="zh" dir="ltr" class="mw-content-ltr"><div class="t-navbar" style=""><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../../c.html" title="c"> C</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="c/language">语言</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="c/header">头文件</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../types.html" title="c/types">类型支持</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../program.html" title="c/program">程序工具</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../variadic.html" title="c/variadic">变参数函数支持</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../memory.html" title="c/memory">动态内存管理</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="c/error">错误处理</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../chrono.html" title="c/chrono">日期和时间工具</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="c/string">字符串库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="c/algorithm">算法</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="c/numeric">数值</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="c/io">输入/输出支持</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="c/locale">本地化支持</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="c/thread">线程支持</a> <span class="t-mark">(C11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="c/atomic">原子操作</a> <span class="t-mark">(C11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="c/experimental">技术规范</a> </td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../language.html" title="c/language">C 语言</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5"> <a href="basic_concepts.html" title="c/language/basic concepts">基本概念</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="../keyword.html" title="c/keyword">关键词</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="../preprocessor.html" title="c/preprocessor">预处理器</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="statements.html" title="c/language/statements">语句</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="expressions.html" title="c/language/expressions">表达式</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="initialization.html" title="c/language/initialization">初始化</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="declarations.html" title="c/language/declarations">声明</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="functions.html" title="c/language/functions">函数</a></td></tr>
<tr class="t-nv"><td colspan="5"> 杂项</td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="history.html" title="c/language/history">C 的历史</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="../experimental.html" title="c/experimental">技术规范</a> </td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="expressions.html" title="c/language/expressions"> 表达式</a><div class="t-navbar-menu"><div><div style="display:inline-block">
<div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5"> 通用 </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="value_category.html" title="c/language/value category">值类别</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="eval_order.html" title="c/language/eval order"> 求值顺序与顺序点</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="constant_expression.html" title="c/language/constant expression">常量表达式</a></td></tr>
<tr class="t-nv"><td colspan="5"> <strong class="selflink">隐式转换</strong></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="generic.html" title="c/language/generic">泛型选择</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="expressions.html#.E5.B8.B8.E9.87.8F.E5.8F.8A.E5.AD.97.E9.9D.A2.E9.87.8F" title="c/language/expressions">常量及字面量</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="integer_constant.html" title="c/language/integer constant">整数常量</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="floating_constant.html" title="c/language/floating constant">浮点常量</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="character_constant.html" title="c/language/character constant">字符常量</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="string_literal.html" title="c/language/string literal">字符串字面量</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="compound_literal.html" title="c/language/compound literal">复合字面量</a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> <a href="expressions.html#.E8.BF.90.E7.AE.97.E7.AC.A6" title="c/language/expressions">运算符</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_precedence.html" title="c/language/operator precedence">运算符优先级</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_member_access.html" title="c/language/operator member access">成员访问与间接</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_logical.html" title="c/language/operator logical">逻辑运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_comparison.html" title="c/language/operator comparison">比较运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_arithmetic.html" title="c/language/operator arithmetic">算术运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_assignment.html" title="c/language/operator assignment">赋值运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_incdec.html" title="c/language/operator incdec">自增减</a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="operator_other.html" title="c/language/operator other">函数调用、逗号、条件运算符</a></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="sizeof.html" title="c/language/sizeof"><span class="t-lines"><span>sizeof</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="_Alignof.html" title="c/language/ Alignof"><span class="t-lines"><span>_Alignof</span></span></a></div><div><span class="t-lines"><span><span class="t-mark">(C11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cast.html" title="c/language/cast">转型运算符</a></td></tr>
</table></div>
</div><div></div></div></div></div><div class="t-navbar-sep"> </div></div>
<p>当表达式用在期待相异类型的语境中时，可以发生<i>转换</i>：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">1L</span><span class="sy4">;</span> <span class="co1">// 表达式 1L 拥有类型 long ，期待 int</span>
n <span class="sy1">=</span> <span class="nu16">2.1</span><span class="sy4">;</span> <span class="co1">// 表达式 2.1 拥有类型 double ，期待 int</span>
<span class="kw4">char</span> <span class="sy2">*</span>p <span class="sy1">=</span> <a href="../memory/malloc.html"><span class="kw403">malloc</span></a><span class="br0">(</span><span class="nu0">10</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 表达式 malloc(10) 拥有类型 void* ，期待 char*</span></pre></div></div>
<p>转换在下列情况下发生：
</p>
<h3><span class="mw-headline" id=".E5.A6.82.E5.90.8C.E8.B5.8B.E5.80.BC.E7.9A.84.E8.BD.AC.E6.8D.A2">如同赋值的转换</span></h3>
<ul><li> 在<a href="operator_assignment.html" title="c/language/operator assignment">赋值</a>运算符中，右运算数的值被转换成左运算数的无限定类型
</li><li> 在<a href="scalar_initialization.html" title="c/language/scalar initialization">标量初始化</a>中，初始化器表达式的值被转换成待初始化对象的无限定类型
</li><li> 在对有原型的<a href="operator_other.html" title="c/language/operator other">函数调用表达式</a>中，每个参数表达式的类型被转换成对应参数的声明类型
</li><li> 在 <a href="return.html" title="c/language/return">return 语句</a>中， <code>return</code> 运算数的值被转换成拥有函数返回类型的对象
</li></ul>
<p>注意在实际赋值中，在转换外，还会移除浮点类型的额外范围和精度，并禁止重叠；这些特性不作用于如同赋值的转换。
</p>
<h3><span class="mw-headline" id=".E9.BB.98.E8.AE.A4.E5.8F.82.E6.95.B0.E6.8F.90.E5.8D.87">默认参数提升</span></h3>
<p>在<a href="operator_other.html#.E5.87.BD.E6.95.B0.E8.B0.83.E7.94.A8" title="c/language/operator other">函数调用表达式</a>中，当调用下列函数时
</p>
<div class="t-li1"><span class="t-li">1)</span> <a href="function_declaration.html" title="c/language/function declaration">无原型函数</a></div>
<div class="t-li1"><span class="t-li">2)</span> <a href="variadic.html" title="c/language/variadic">变参数函数</a>，其中参数表达式是匹配省略号参数的尾随参数之一</div>
<p>每个整数类型的参数都会经历<i>整数提升</i>（见后述），而每个 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span></span></span> 类型参数都隐式转换为 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span></span></span> 类型
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> add_nums<span class="br0">(</span><span class="kw4">int</span> count, ...<span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">int</span> sum <span class="sy1">=</span> add_nums<span class="br0">(</span><span class="nu0">2</span>, <span class="st0">'c'</span>, <span class="kw2">true</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// add_nums 将以三个 int 调用： (2, 99, 1)</span></pre></div></div>
<p>注意 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span> 和 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span> 在此语境中不会提升到 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span> 和 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span> 。
</p>
<h3><span class="mw-headline" id=".E9.80.9A.E5.B8.B8.E7.AE.97.E6.9C.AF.E8.BD.AC.E6.8D.A2">通常算术转换</span></h3>
<p>下列算术运算符的参数会经历隐式转换，为了含有<i>共用实数类型</i>，这是执行计算所用的类型：
</p>
<ul><li> <a href="operator_arithmetic.html" title="c/language/operator arithmetic">二元算术</a> *, /, %, +, -
</li><li> <a href="operator_comparison.html" title="c/language/operator comparison">关系运算符</a> &lt;, &gt;, &lt;=, &gt;=, ==, !=
</li><li> <a href="operator_arithmetic.html" title="c/language/operator arithmetic">二元逐位算术</a> &amp;, ^, |, 
</li><li> <a href="operator_other.html" title="c/language/operator other">条件运算符</a> ?:
</li></ul>
<div class="t-li1"><span class="t-li">1)</span> 若一个运算数是 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">double</span></span></span> 、 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span> 或 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span> ，则另一运算数会按下列方式隐式转换：
<dl><dd><ul><li>整数或实浮点类型转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">double</span></span></span>
</li><li>复数类型转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span>
</li><li>虚数类型转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">long</span> <span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span></li></ul></dd></dl></div>


<div class="t-li1"><span class="t-li">2)</span> 否则，若一个运算数是 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span></span></span> 、 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span> 或 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span> ，则另一运算数会按下列方式隐式转换：
<dl><dd><ul><li>整数或实浮点类型转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span></span></span>
</li><li>复数类型转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span>
</li><li>虚数类型转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span></li></ul></dd></dl></div>


<div class="t-li1"><span class="t-li">3)</span> 否则，若一个运算数是<span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span></span></span> 、 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span> 或 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span> ，则另一运算数会按下列方式隐式转换：
<dl><dd><ul><li>整数类型转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span></span></span> （唯一可能的实数类型是 float ，它保持原态）
</li><li>复数类型保持 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a></span></span>
</li><li>虚数类型保持 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">float</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a></span></span></li></ul></dd></dl></div>


<div class="t-li1"><span class="t-li">4)</span> 否则两个运算数均为整数。此情况下，
<dl><dd>首先，两个运算数都会经历<i>整数提升</i>（见后述）。然后
<ul><li> 若两类型在提升后相同，则该类型即为共用类型
</li><li> 否则，若两运算数在提升后有相同的符号性（均为有符号或均为无符号），则拥有较低<i>转换等级</i>（见后述）者会隐式转换成拥有较高<i>转换等级</i>的运算数的类型
</li><li> 否则，两者符号性不同：若无符号类型运算数拥有大于或等于有符号类型运算数的<i>转换等级</i>，则有符号类型运算数会隐式转换成无符号类型
</li><li> 否则，两者符号性不同且有符号运算数的等级大于无符号运算数的等级。此情况中，若有符号类型可以表达无符号类型的所有值，则有无符号类型的运算数被隐式转换成有符号运算数的类型。
</li><li> 否则，两个运算数都会经历隐式转换，到有符号类型的无符号类型对应者。
</li></ul>
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="nu0">1</span>.<span class="me1">f</span> <span class="sy2">+</span> <span class="nu0">20000001</span><span class="sy4">;</span> <span class="co1">// int 被转换成 float ，给出 20000000.00</span>
                <span class="co1">// 相加后舍入到 float ，给出20000000.00</span>
<span class="br0">(</span><span class="kw4">char</span><span class="br0">)</span><span class="st0">'a'</span> <span class="sy2">+</span> <span class="nu0">1L</span><span class="sy4">;</span> <span class="co1">// 首先，char 被提升回 int。</span>
                <span class="co1">// 这是有符号+有符号的情形，等级不同</span>
                <span class="co1">// int 被转换成 long ，结果是 signed long 的 98</span>
2u <span class="sy2">-</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="co1">// 有符号/无符号，等级相同</span>
         <span class="co1">// 10 被转换成无符号，无符号数学运算为模 UINT_MAX+1</span>
         <span class="co1">// 对于 32 位 int ，结果是 unsigned int 类型的 4294967288 （即 UINT_MAX-7 ）</span>
0UL <span class="sy2">-</span> 1LL<span class="sy4">;</span> <span class="co1">// 有符号/无符号相异等级，有符号的等级较大。</span>
           <span class="co1">// 若 sizeof(long) == sizeof(long long) ，则有符号数不能表示所有无符号数</span>
           <span class="co1">// 这是最后一种情况：两个运算数都被转换成 unsigned long long</span>
           <span class="co1">// 结果是 unsigned long long 类型的 18446744073709551615（ ULLONG_MAX ）</span></pre></div></div></div>
<p>结果类型按下列方式确定：
</p>
<ul><li> 若两运算数均为复数，则结果类型是复数
</li><li> 若两运算数均为虚数，则结果类型是虚数 
</li><li> 若两运算数均为实数，则结果类型为实数
</li><li> 若两浮点运算数拥有不同定义域（复数 VS 实数、复数 VS 虚数，或虚数 VS 实数），则结果类型是复数
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a> z <span class="sy1">=</span> <span class="nu0">1</span> <span class="sy2">+</span> <span class="nu0">2</span><span class="sy2">*</span>I<span class="sy4">;</span>
<span class="kw4">double</span> f <span class="sy1">=</span> <span class="nu16">3.0</span><span class="sy4">;</span>
z <span class="sy2">+</span> f<span class="sy4">;</span> <span class="co1">// z 保持原态，f 被转换成 double ，结果是 double complex</span></pre></div></div>
<p>一如常态，浮点运算符的结果可能会有大于其类型所指示的范围和及精度（见 <span class="t-lc"><a href="../types/limits/FLT_EVAL_METHOD.html" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></span> ）。
</p><p>注意：实数和虚数运算数不会隐式转换成复数，因为这么做需要额外计算，会在牵涉到无穷大、NaN和有符号零的具体情况时产生不想要的结果。例如，若实数被转换成复数，2.0×(3.0+i∞)会按照(2.0+i0.0)×(3.0+i∞) ⇒ (2.0×3.0–0.0×∞) + i(2.0×∞+0.0×3.0) ⇒ NaN+i∞求值，而非正确的6.0+i∞。若虚数被转换成复数，则i2.0×(∞+i3.0)会按照(0.0+i2.0) × (∞+i3.0) ⇒ (0.0×∞ – 2.0×3.0) + i(0.0×3.0 + 2.0×∞) ⇒ NaN + i∞求值，而非–6.0 + i∞。
</p><p>注意：无关乎通常算术转换，计算可能在<a href="https://zh.cppreference.com/mwiki/index.php?title=c/language/as_if&amp;action=edit&amp;redlink=1" class="new" title="c/language/as if（页面不存在）">如同规则</a>下，始终以窄于指示符的类型进行。
</p>
<h3><span class="mw-headline" id=".E5.80.BC.E5.8F.98.E6.8D.A2">值变换</span></h3>
<h4><span class="mw-headline" id=".E5.B7.A6.E5.80.BC.E8.BD.AC.E6.8D.A2">左值转换</span></h4>
<p>任何非数组类型的<a href="value_category.html" title="c/language/value category">左值表达式</a>，在用于异于下列语境时
</p>
<ul><li> 作为<a href="operator_member_access.html" title="c/language/operator member access">取值运算符</a>的运算数（若允许）
</li><li> 作为前/后<a href="operator_incdec.html" title="c/language/operator incdec">自增减运算符</a>的运算数。
</li><li> 作为<a href="operator_member_access.html" title="c/language/operator member access">成员访问</a>（点）运算符的左运算数。
</li><li> 作为<a href="operator_assignment.html" title="c/language/operator assignment">赋值与复合赋值</a>运算符的左运算数。
</li><li> 作为 <a href="sizeof.html" title="c/language/sizeof">sizeof</a> 的运算数
</li></ul>
<p>会经历<i>左值转换</i>：类型保持相同，但失去 <a href="const.html" title="c/language/const">const</a>/<a href="volatile.html" title="c/language/volatile">volatile</a>/<a href="restrict.html" title="c/language/restrict">restrict</a> 限定符及<a href="atomic.html" title="c/language/atomic">原子</a>属性，若原先有。值保持相同，但失去其左值属性（不再能取其地址）。
</p><p>若左值拥有不完整类型，则行为未定义。
</p><p>若左值指代自动存储期的对象，该对象从不被取地址，且若该对象未被初始化（没有用初始化器声明且没有在使用它前赋值），则行为未定义。
</p><p>此转换模拟从内存中其位置加载对象的值。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">volatile</span> <span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu0">1</span><span class="sy4">;</span>
<span class="kw4">int</span> x <span class="sy1">=</span> n<span class="sy4">;</span>            <span class="co1">// n 上左值转换读 n 的的值</span>
<span class="kw4">volatile</span> <span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span> <span class="co1">// 无左值转换：不读 n 的值</span></pre></div></div>
<h4><span class="mw-headline" id=".E6.95.B0.E7.BB.84.E5.88.B0.E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">数组到指针转换</span></h4>
<p>任何<a href="array.html" title="c/language/array">数组类型</a>的<a href="value_category.html" title="c/language/value category">左值表达式</a>，在用于异于下列语境时
</p>
<ul><li> 作为<a href="operator_member_access.html" title="c/language/operator member access">取址运算符</a>的运算数
</li><li> 作为 <a href="sizeof.html" title="c/language/sizeof">sizeof</a> 的运算数
</li><li> 作为用于<a href="array_initialization.html" title="c/language/array initialization">数组初始化</a>的字符串字面量
</li></ul>
<p>会经历到指向其首元素的非左值指针的转换。
</p><p>若数组声明为 <a href="storage_duration.html" title="c/language/storage duration">register</a> ，则行为未定义。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> a<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span>, b<span class="br0">[</span><span class="nu0">3</span><span class="br0">]</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span><span class="sy4">;</span>
<span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> a<span class="sy4">;</span>      <span class="co1">// 转换成 &amp;a[0]</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>q<span class="br0">)</span><span class="br0">[</span><span class="nu0">4</span><span class="br0">]</span> <span class="sy1">=</span> b<span class="sy4">;</span> <span class="co1">// 转换成 &amp;b[0]</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.87.BD.E6.95.B0.E5.88.B0.E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">函数到指针转换</span></h4>
<p>任何函数指代器表达式，在用于异于下列语境时
</p>
<ul><li> 作为<a href="operator_member_access.html" title="c/language/operator member access">取址运算符</a>的运算数
</li><li> 作为 <a href="sizeof.html" title="c/language/sizeof">sizeof</a> 的运算数
</li></ul>
<p>会经历到指向表达式所指代函数的指针的转换。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> f<span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="sy4">;</span>
<span class="kw4">int</span> <span class="br0">(</span><span class="sy2">*</span>p<span class="br0">)</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">=</span> f<span class="sy4">;</span> <span class="co1">// 转换成 &amp;f</span>
<span class="br0">(</span><span class="sy2">***</span>p<span class="br0">)</span><span class="br0">(</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 重复解引用到 f 和转换回 &amp;f</span></pre></div></div>
<h3><span class="mw-headline" id=".E9.9A.90.E5.BC.8F.E8.BD.AC.E6.8D.A2.E8.AF.AD.E4.B9.89">隐式转换语义</span></h3>
<p>隐式转换，要么是<i>如同赋值</i>要么是<i>通常算术转换</i>，由二阶段组成：
</p>
<div class="t-li1"><span class="t-li">1)</span> 值变换（若可应用）</div>
<div class="t-li1"><span class="t-li">2)</span> 下列转换之一（若它能产生目标类型）</div>
<h4><span class="mw-headline" id=".E5.85.BC.E5.AE.B9.E7.B1.BB.E5.9E.8B">兼容类型</span></h4>
<p>将任何类型的值转换成任何<a href="type.html#.E5.85.BC.E5.AE.B9.E7.B1.BB.E5.9E.8B" title="c/language/types">兼容类型</a>始终是无操作，且不改变表示。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><a href="../types/integer.html"><span class="kw120">uint8_t</span></a> <span class="br0">(</span><span class="sy2">*</span>a<span class="br0">)</span><span class="br0">[</span><span class="nu0">10</span><span class="br0">]</span><span class="sy4">;</span>         <span class="co1">// 若 uint8_t 是对 unsigned char 的 typedef</span>
<span class="kw4">unsigned</span> <span class="kw4">char</span> <span class="br0">(</span><span class="sy2">*</span>b<span class="br0">)</span><span class="br0">[</span><span class="br0">]</span> <span class="sy1">=</span> a<span class="sy4">;</span> <span class="co1">// 则这些指针类型是兼容的</span></pre></div></div>
<h4><span class="mw-headline" id=".E6.95.B4.E6.95.B0.E6.8F.90.E5.8D.87">整数提升</span></h4>
<p>整数提升是任何<i>等级</i>小于或等于 int <i>等级</i>的整数类型，或是 _Bool 、 signed int 、 unsigned int 类型的<a href="bit_field.html" title="c/language/bit field">位域</a>类型的值到 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">int</span></span></span> 或 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">unsigned</span> <span class="kw4">int</span></span></span> 类型值的隐式转换。
</p><p>若 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">int</span></span></span> 能表示原类型的整个值域（或原位域的值域），则值转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">int</span></span></span> 类型。否则值转化成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">unsigned</span> <span class="kw4">int</span></span></span> 类型。
</p><p>整数提升保持值，包含符号：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> main<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span> <span class="br0">{</span>
   <span class="kw4">void</span> f<span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 旧式函数声明</span>
   <span class="kw4">char</span> x <span class="sy1">=</span> <span class="st0">'a'</span><span class="sy4">;</span> <span class="co1">// 整数转换 int 到 char</span>
   f<span class="br0">(</span>x<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 整数提升 char 回 int</span>
<span class="br0">}</span>
<span class="kw4">void</span> f<span class="br0">(</span>x<span class="br0">)</span> <span class="kw4">int</span> x<span class="sy4">;</span> <span class="br0">{</span><span class="br0">}</span> <span class="co1">// 函数期待int</span></pre></div></div>
<p>上述的<i>等级</i>是每个<a href="type.html" title="c/language/types">整数类型</a>的属性，定义如下：
</p>
<div class="t-li1"><span class="t-li">1)</span> 所有有符号整数的等级都不同，且按其精度递增：signed char 等级 &lt; short 等级 &lt; int 等级 &lt; long 等级 &lt; long long 等级</div>
<div class="t-li1"><span class="t-li">2)</span> 所有有符号整数等级与对应无符号整数等级相等</div>
<div class="t-li1"><span class="t-li">3)</span> 任何标准整数类型的等级大于任何相同大小的非标准整数类型等级（即 __int64 等级 &lt; long long 等级，但根据规则<span class="t-v">(1)</span>， long long 等级 &lt; __int128 等级）</div>
<div class="t-li1"><span class="t-li">4)</span> char 的等级等于 signed char 和 unsigned char 的等级</div>
<div class="t-li1"><span class="t-li">5)</span> _Bool 的等级小于任何其他标准整数类型的等级</div>
<div class="t-li1"><span class="t-li">6)</span> 任何枚举类型的等级等于其兼容整数类型的等级</div>
<div class="t-li1"><span class="t-li">7)</span> 等级排行是传递性的：若 T1 等级 &lt; T2 等级 且 T2 等级 &lt; T3 等级 ，则 T1 等级 &lt; T3 等级</div>
<div class="t-li1"><span class="t-li">8)</span> 任何上面未提及的扩展整数类型排行方面是实现定义的</div>
<p>注意：整数提升仅应用于
</p>
<ul><li> <i>通常算术转换</i>的一部分（见前述）
</li><li> <i>默认参数提升</i>的一部分（见前述）
</li><li> 给一元算术运算符 + 和 - 的运算数
</li><li> 给一元位运算符的运算数
</li><li> 给位移运算符 &lt;&lt; 和 &gt;&gt; 的两个运算数
</li></ul>
<h4><span class="mw-headline" id=".E5.B8.83.E5.B0.94.E8.BD.AC.E6.8D.A2">布尔转换</span></h4>
<p>任何标量类型的值可以隐式转换成 _Bool 。比较等于零的值转换成 <span class="t-c"><span class="mw-geshi c source-c">​<span class="nu0">0</span>​</span></span> ，所有其他值转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="nu0">1</span></span></span>
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1">bool b1 <span class="sy1">=</span> <span class="nu16">0.5</span><span class="sy4">;</span>              <span class="co1">// b1 == 1 （0.5 转换成 int 会是零）</span>
bool b2 <span class="sy1">=</span> <span class="nu16">2.0</span><span class="sy2">*</span><a href="../numeric/complex/Imaginary_I.html"><span class="kw746">_Imaginary_I</span></a><span class="sy4">;</span> <span class="co1">// b2 == 1 （但转换成 int 会是零）</span>
bool b3 <span class="sy1">=</span> <span class="nu16">0.0</span> <span class="sy2">+</span> <span class="nu16">3.0</span><span class="sy2">*</span>I<span class="sy4">;</span>      <span class="co1">// b3 == 1 （但转换成 int 会是零）</span>
bool b4 <span class="sy1">=</span> <span class="nu16">0.0</span><span class="sy2">/</span><span class="nu16">0.0</span><span class="sy4">;</span>          <span class="co1">// b4 == 1 （NaN 与零比较不相等）</span></pre></div></div>
<h4><span class="mw-headline" id=".E6.95.B4.E6.95.B0.E8.BD.AC.E6.8D.A2">整数转换</span></h4>
<p>任何整数类型的值可以隐式转换到任何其他整数类型。除了上述整数提升和布尔转换所提及的情况，规则为：
</p>
<ul><li> 若目标类型能表示值，则值不变
</li><li> 否则，若目标类型为无符号，则源值会重复减或加值 <span class="texhtml" style="white-space: nowrap;">2<span class="t-su">b<br></span></span> ，其中 <span class="texhtml" style="white-space: nowrap;">b</span> 是目标类型的位数，直到结果符合目标类型。换言之，无符号整数实现模算术。
</li><li> 否则，若目标类型为有符号，则行为是实现定义的（可能包括引发信号）
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">char</span> x <span class="sy1">=</span> <span class="st0">'a'</span><span class="sy4">;</span> <span class="co1">// int -&gt; char，结果不变</span>
<span class="kw4">unsigned</span> <span class="kw4">char</span> n <span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">123456</span><span class="sy4">;</span> <span class="co1">// 目标是无符号数，结果为 192 （即 -123456+483*256 ）</span>
<span class="kw4">signed</span> <span class="kw4">char</span> m <span class="sy1">=</span> <span class="nu0">123456</span><span class="sy4">;</span>    <span class="co1">// 目标是有符号数，结果实现定义</span>
<a href="../error/assert.html"><span class="kw407">assert</span></a><span class="br0">(</span><span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span> <span class="sy1">&gt;</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">)</span><span class="sy4">;</span>  <span class="co1">// 断言失败：</span>
                           <span class="co1">// 运算符 &gt; 要求 -1 到 size_t 的转换，</span>
                           <span class="co1">// 目标为无符号，结果是 SIZE_MAX</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.AE.9E.E6.B5.AE.E7.82.B9.E6.95.B4.E6.95.B0.E8.BD.AC.E6.8D.A2">实浮点整数转换</span></h4>
<p>任何实浮点类型的有限值可以隐式转换到任何整数类型。除了上述布尔转换所提及的情况，规则为：
</p>
<ul><li> 忽略小数部分（向零取整）。
</li></ul>
<dl><dd><ul><li> 若结果值可表示成目标类型，则使用该值
</li><li> 否则，行为未定义
</li></ul>
</dd></dl>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n <span class="sy1">=</span> <span class="nu16">3.14</span><span class="sy4">;</span> <span class="co1">// n == 3</span>
<span class="kw4">int</span> x <span class="sy1">=</span> <span class="nu19">1e10</span><span class="sy4">;</span> <span class="co1">// 对于 32 位 int 是未定义行为</span></pre></div></div>
<p>任何整数类型的值可以隐式转换成任何实浮点类型。
</p>
<ul><li> 若值能被目标类型准确表示，则它不变
</li><li> 若值能被表示，但无法准确表示，则结果是最接近的较高或较低值（换言之，舍入方向是实现定义的），尽管若支持IEEE算术，则向最近舍入。此情况下是否引发 <span class="t-lc"><a href="../numeric/fenv/FE_exceptions.html" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a></span> 是未指定的。
</li><li> 若值不能被表示，则行为未定义，尽管若支持 IEEE 算术，则引发 <span class="t-lc"><a href="../numeric/fenv/FE_exceptions.html" title="c/numeric/fenv/FE exceptions">FE_INVALID</a></span> 且值为未指定。
</li></ul>
<p>此转换的结果可能拥有大于其目标类型所指示的值和精度（见 <span class="t-lc"><a href="../types/limits/FLT_EVAL_METHOD.html" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></span> ）。
</p><p>若在浮点到整数转换中控制 <span class="t-lc"><a href="../numeric/fenv/FE_exceptions.html" title="c/numeric/fenv/FE exceptions">FE_INEXACT</a></span> ，则可以使用 <span class="t-lc"><a href="../numeric/math/rint.html" title="c/numeric/math/rint">rint</a></span> 及 <span class="t-lc"><a href="../numeric/math/nearbyint.html" title="c/numeric/math/nearbyint">nearbyint</a></span> 。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> d <span class="sy1">=</span> <span class="nu0">10</span><span class="sy4">;</span> <span class="co1">// d = 10.00</span>
<span class="kw4">float</span> f <span class="sy1">=</span> <span class="nu0">20000001</span><span class="sy4">;</span> <span class="co1">// f = 20000000.00 (FE_INEXACT)</span>
<span class="kw4">float</span> x <span class="sy1">=</span> <span class="nu0">1</span><span class="sy2">+</span><span class="br0">(</span><span class="kw4">long</span> <span class="kw4">long</span><span class="br0">)</span><a href="../types/limits.html"><span class="kw377">FLT_MAX</span></a><span class="sy4">;</span> <span class="co1">// 未定义行为</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.AE.9E.E6.B5.AE.E7.82.B9.E6.95.B0.E8.BD.AC.E6.8D.A2">实浮点数转换</span></h4>
<p>任何实浮点类型的值可以隐式转换到任何其他实浮点类型。
</p>
<ul><li> 若值能被目标类型准确表示，则它不变
</li><li>  若值能被表示，但无法准确表示，则结果是最接近的较高或较低值（换言之，舍入方向是实现定义的），尽管若支持IEEE算术，则向最近舍入
</li><li> 若值不能被表示，则行为未定义
</li></ul>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">本节未完成<br>原因：检查 IEEE ，是否适用于有符号无穷大 </td></tr></table>
<p>此转换的结果可能拥有大于其目标类型所指示的值和精度（见 <span class="t-lc"><a href="../types/limits/FLT_EVAL_METHOD.html" title="c/types/limits/FLT EVAL METHOD">FLT_EVAL_METHOD</a></span> ）。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> d <span class="sy1">=</span> <span class="nu16">0.1</span><span class="sy4">;</span> <span class="co1">// d = 0.1000000000000000055511151231257827021181583404541015625</span>
<span class="kw4">float</span> f <span class="sy1">=</span> d<span class="sy4">;</span>    <span class="co1">// f = 0.100000001490116119384765625</span>
<span class="kw4">float</span> x <span class="sy1">=</span> <span class="nu0">2</span><span class="sy2">*</span><span class="br0">(</span><span class="kw4">double</span><span class="br0">)</span><a href="../types/limits.html"><span class="kw377">FLT_MAX</span></a><span class="sy4">;</span> <span class="co1">// 未定义</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.A4.8D.E6.95.B0.E7.B1.BB.E5.9E.8B.E8.BD.AC.E6.8D.A2">复数类型转换</span></h4>
<p>任何复数类型的值可以隐式转换成任何另一种复数类型。实部和虚部各自遵循实浮点类型的转换规则。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a> d <span class="sy1">=</span> <span class="nu16">0.1</span> <span class="sy2">+</span> <span class="nu16">0.1</span><span class="sy2">*</span>I<span class="sy4">;</span>
<span class="kw4">float</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a> f <span class="sy1">=</span> d<span class="sy4">;</span> <span class="co1">// f 为 (0.100000001490116119384765625, 0.100000001490116119384765625)</span></pre></div></div>
<h4><span class="mw-headline" id=".E8.99.9A.E6.95.B0.E7.B1.BB.E5.9E.8B.E8.BD.AC.E6.8D.A2">虚数类型转换</span></h4>
<p>任何虚数类型的值可以隐式转换成另一种虚数类型。虚部遵循实浮点类型的转换规则。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a> d <span class="sy1">=</span> <span class="nu16">0.1</span><span class="sy2">*</span><a href="../numeric/complex/Imaginary_I.html"><span class="kw746">_Imaginary_I</span></a><span class="sy4">;</span>
<span class="kw4">float</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a> f <span class="sy1">=</span> d<span class="sy4">;</span> <span class="co1">// f 为 0.100000001490116119384765625*I</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.AE.9E.E5.A4.8D.E6.95.B0.E8.BD.AC.E6.8D.A2">实复数转换</span></h4>
<p>任何实浮点类型的值可以隐式转换成任何复数类型。
</p>
<ul><li> 结果的实部根据实浮点类型的转换规则确定
</li><li> 结果的虚部是正零（或非 IEEE 系统上的无符号零）
</li></ul>
<p>任何复数类型的值可以隐式转换成任何实浮点类型
</p>
<ul><li> 实部遵循实浮点类型的规则转换
</li><li> 虚部被忽略
</li></ul>
<p>注意：在复到实转换中，虚部的 NaN 不会传播到实结果。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> <a href="../numeric/complex/complex.html"><span class="kw743">complex</span></a> z <span class="sy1">=</span> <span class="nu16">0.5</span> <span class="sy2">+</span> <span class="nu0">3</span><span class="sy2">*</span>I<span class="sy4">;</span>
<span class="kw4">float</span> f <span class="sy1">=</span> z<span class="sy4">;</span>  <span class="co1">// 舍去虚部，设置 f 为 0.5</span>
z <span class="sy1">=</span> f<span class="sy4">;</span>        <span class="co1">// 设置 z 为 0.5 + 0*I</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.AE.9E.E8.99.9A.E6.95.B0.E8.BD.AC.E6.8D.A2">实虚数转换</span></h4>
<p>任何虚数类型的值可以转换到任何实数类型（整数或浮点数）。结果始终是正（或无符号）零，除非目标类型是 _Bool ，这种情况下会应用布尔转换规则。
</p><p>任何实数类型的值可以隐式转换成任何虚数类型。结果始终是虚数正零。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a> z <span class="sy1">=</span> <span class="nu0">3</span><span class="sy2">*</span>I<span class="sy4">;</span>
bool b <span class="sy1">=</span> z<span class="sy4">;</span>  <span class="co1">// 布尔转换：设置 b 为 true </span>
<span class="kw4">float</span> f <span class="sy1">=</span> z<span class="sy4">;</span> <span class="co1">// 实虚转换：设置 f 为 0.0 </span>
z <span class="sy1">=</span> <span class="nu16">3.14</span><span class="sy4">;</span>    <span class="co1">// 虚实转换：设置 z 为 0*_Imaginary_I</span></pre></div></div>
<h4><span class="mw-headline" id=".E5.A4.8D.E8.99.9A.E6.95.B0.E8.BD.AC.E6.8D.A2">复虚数转换</span></h4>
<p>任何虚数类型的值可以隐式转换到任何复数类型。
</p>
<ul><li> 结果的实部是正零
</li><li> 结果的虚部遵循对应的实类型转换规则
</li></ul>
<p>任何复数类型可以隐式转换到任何虚数类型
</p>
<ul><li> 实部被忽略
</li><li> 结果的虚部遵循对应的实数类型转换规则
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">double</span> <a href="../numeric/complex/imaginary.html"><span class="kw745">imaginary</span></a> z <span class="sy1">=</span> I <span class="sy2">*</span> <span class="br0">(</span><span class="nu0">3</span><span class="sy2">*</span>I<span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 复结果 -3.0+0i 失去实部</span>
                                <span class="co1">// 设置 z 为 0*_Imaginary_I</span></pre></div></div>
<h4><span class="mw-headline" id=".E6.8C.87.E9.92.88.E8.BD.AC.E6.8D.A2">指针转换</span></h4>
<p>指向 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">void</span></span></span> 可与任何指向对象指针类型间相互隐式转换，并拥有下列语义：
</p>
<ul><li> 若指向对象的指针被转换成指向void的指针再转换回来，则其值与原指针比较相等。
</li><li> 不提供其他保证
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> <a href="../memory/malloc.html"><span class="kw403">malloc</span></a><span class="br0">(</span><span class="nu0">10</span> <span class="sy2">*</span> <span class="kw4">sizeof</span><span class="br0">(</span><span class="kw4">int</span><span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// malloc 返回 void*</span></pre></div></div>
<p>指向无限定类型的指针可以隐式转换成指向该类型有限定版本的指针（换言之，可以添上 <a href="const.html" title="c/language/const">const</a> 、 <a href="volatile.html" title="c/language/volatile">volatile</a> 、 及 <a href="restrict.html" title="c/language/restrict">restrict</a> 限定符）。原指针与结果比较相等。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span> n<span class="sy4">;</span>
<span class="kw4">const</span> <span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="sy3">&amp;</span>n<span class="sy4">;</span> <span class="co1">// &amp;n 拥有类型 int*</span></pre></div></div>
<p>任何拥有值 <span class="t-c"><span class="mw-geshi c source-c">​<span class="nu0">0</span>​</span></span> 的整数<a href="constant_expression.html" title="c/language/constant expression">常量表达式</a>也是一个拥有转换成 <span class="t-c"><span class="mw-geshi c source-c"><span class="kw4">void</span><span class="sy2">*</span></span></span> 类型的零的整数指针表达式，可以隐式转换成任意指针类型（既可以是指向对象指针，又可以是指向函数指针）。结果是该类型的空指针值，保证与任何该类型的非空指针值比较不相等。此整数或 void* 表达式又称<i>空指针常量</i>，而且标准库提供此常量作为宏 <span class="t-lc"><a href="../types/NULL.html" title="c/types/NULL">NULL</a></span> 的一种定义。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">int</span><span class="sy2">*</span> p <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="kw4">double</span><span class="sy2">*</span> q <span class="sy1">=</span> <a href="../types/NULL.html"><span class="kw103">NULL</span></a><span class="sy4">;</span></pre></div></div>
<h3><span class="mw-headline" id=".E6.B3.A8.E6.84.8F">注意</span></h3>
<p>尽管有符号整数在任何算术运算符中的溢出是未定义行为，在整数类型转换中溢出有符号整数仅是未指定行为。
</p><p>另一方面，尽管任何算术运算符（和整数转换）中无符号整数溢出是良好定义的操作，并遵循模算术规则，在浮点到整数转换中溢出无符号整数是未定义行为：可以转换成无符号整数的实浮点类型值是来自开区间 <span class="texhtml" style="white-space: nowrap;">(-1; Unnn_MAX+1)</span> 的值。
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">unsigned</span> <span class="kw4">int</span> n <span class="sy1">=</span> <span class="sy2">-</span><span class="nu16">1.0</span><span class="sy4">;</span> <span class="co1">// 未定义行为</span></pre></div></div>
<p>指针和整数间（除了从指针到 _Bool 和从拥有零值的整数常量表达式到指针）、指向对象指针间（除了从或到指向 void 的指针）以及指向函数指针间（除非函数拥有兼容类型）的转换始终非隐式，并要求有<a href="cast.html" title="c/language/cast">转型运算符</a>。
</p><p>不存在（隐式或显式的）指向函数指针与指向对象指针（包括 void* ）或整数间的转换。
</p>
<h3><span class="mw-headline" id=".E5.BC.95.E7.94.A8">引用</span></h3>
<div class="t-ref-std-11">
<ul><li> C11 standard (ISO/IEC 9899:2011): 
</li></ul>
<dl><dd><ul><li> 6.3 Conversions (p: 50-56)
</li></ul>
</dd></dl>
<div class="t-ref-std-c99">
<ul><li> C99 standard (ISO/IEC 9899:1999): 
</li></ul>
<dl><dd><ul><li> 6.3 Conversions (p: 42-48)
</li></ul>
</dd></dl>
<div class="t-ref-std-c89">
<ul><li> C89/C90 standard (ISO/IEC 9899:1990): 
</li></ul>
<dl><dd><ul><li> 3.2 Conversions 
</li></ul>
</dd></dl>
</div>
<h3><span class="mw-headline" id=".E5.8F.82.E9.98.85">参阅</span></h3>
<table class="t-dsc-begin">

</table></div>
</div>

<!-- 
NewPP limit report
Preprocessor visited node count: 3169/1000000
Preprocessor generated node count: 9736/1000000
Post‐expand include size: 50479/2097152 bytes
Template argument size: 10506/2097152 bytes
Highest expansion depth: 17/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_zh_:pcache:idhash:7944-0!*!0!!zh!*!zh!* and timestamp 20190822201711 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    来自“<a href="https://zh.cppreference.com/mwiki/index.php?title=c/language/conversion&amp;oldid=51952">https://zh.cppreference.com/mwiki/index.php?title=c/language/conversion&amp;oldid=51952</a>”                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>导航</h5>
            <ul><li><a href="https://zh.cppreference.com/w/c/language/conversion">Online version</a></li><li>Offline version retrieved 2019-08-25 10:54.</li></ul></div>
                        <ul id="footer-info">
                                    <li id="footer-info-lastmod"> 本页面最后修改于2018年1月2日 (星期二) 04:31。</li>
                                    <li id="footer-info-viewcount">此页面已被浏览过4,459次。</li>
                            </ul>
                    </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.MathJax","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 1.541 secs. -->
	</body>
<!-- Cached 20190822201711 -->
</html>