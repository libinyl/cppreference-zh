<!DOCTYPE html>
<html lang="zh" dir="ltr" class="client-nojs">
<head>
<title>标准库头文件 &lt;algorithm&gt;</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../../../common/favicon.ico">
<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-css:7:15cea3ec788a65b5187d4018eed543bf */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/header/algorithm","wgTitle":"cpp/header/algorithm","wgCurRevisionId":60803,"wgArticleId":10120,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"zh","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"zh","wgMonthNames":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgMonthNamesShort":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgRelevantPageName":"cpp/header/algorithm","wgUserVariant":"zh","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"zh","language":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-MathJax":1,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-js:7:258d7cd6aa9aa67dee25e01fb6a9e505 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_header_algorithm skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
<div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<h1 id="firstHeading" class="firstHeading"><span style="font-size:0.7em; line-height:130%">标准库头文件</span> &lt;algorithm&gt;</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">来自cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../header.html" title="cpp/header">header</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="zh" dir="ltr" class="mw-content-ltr"><div class="t-navbar" style=""><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language">语言</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header">标准库头文件</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../freestanding.html" title="cpp/freestanding"> 自立与有宿主实现</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../named_req.html" title="cpp/named req">具名要求</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html#.E8.AF.AD.E8.A8.80.E6.94.AF.E6.8C.81" title="cpp/utility">语言支持库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concepts.html" title="cpp/concepts">概念库</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="cpp/error">诊断库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility">工具库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string">字符串库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container">容器库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator">迭代器库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../ranges.html" title="cpp/ranges"> 范围库</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm">算法库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric">数值库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io">输入/输出库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale">本地化库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex">正则表达式库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic">原子操作库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread">线程支持库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem">文件系统库</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental">技术规范</a> </td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../header.html" title="cpp/header"> 标准库头文件</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h2"><td colspan="5"> 语言支持</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cstddef.html" title="cpp/header/cstddef"><tt>&lt;cstddef&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="limits.html" title="cpp/header/limits"><tt>&lt;limits&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="climits.html" title="cpp/header/climits"><tt>&lt;climits&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/header/coroutine&amp;action=edit&amp;redlink=1" class="new" title="cpp/header/coroutine（页面不存在）"><tt>&lt;coroutine&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cfloat.html" title="cpp/header/cfloat"><tt>&lt;cfloat&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cstdint.html" title="cpp/header/cstdint"><tt>&lt;cstdint&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="new.html" title="cpp/header/new"><tt>&lt;new&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/header/source_location&amp;action=edit&amp;redlink=1" class="new" title="cpp/header/source location（页面不存在）"><tt>&lt;source_location&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="typeinfo.html" title="cpp/header/typeinfo"><tt>&lt;typeinfo&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="exception.html" title="cpp/header/exception"><tt>&lt;exception&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="initializer_list.html" title="cpp/header/initializer list"><tt>&lt;initializer_list&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="version.html" title="cpp/header/version"><tt>&lt;version&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="csignal.html" title="cpp/header/csignal"><tt>&lt;csignal&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="csetjmp.html" title="cpp/header/csetjmp"><tt>&lt;csetjmp&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cstdarg.html" title="cpp/header/cstdarg"><tt>&lt;cstdarg&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 概念</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="concepts.html" title="cpp/header/concepts"><tt>&lt;concepts&gt;</tt></a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 诊断</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="stdexcept.html" title="cpp/header/stdexcept"><tt>&lt;stdexcept&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cassert.html" title="cpp/header/cassert"><tt>&lt;cassert&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cerrno.html" title="cpp/header/cerrno"><tt>&lt;cerrno&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="system_error.html" title="cpp/header/system error"><tt>&lt;system_error&gt;</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 通用工具</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="utility.html" title="cpp/header/utility"><tt>&lt;utility&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="memory.html" title="cpp/header/memory"><tt>&lt;memory&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="memory_resource.html" title="cpp/header/memory resource"><tt>&lt;memory_resource&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="scoped_allocator.html" title="cpp/header/scoped allocator"><tt>&lt;scoped_allocator&gt;</tt></a>    </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="compare.html" title="cpp/header/compare"><tt>&lt;compare&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="bitset.html" title="cpp/header/bitset"><tt>&lt;bitset&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="tuple.html" title="cpp/header/tuple"><tt>&lt;tuple&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="optional.html" title="cpp/header/optional"><tt>&lt;optional&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="any.html" title="cpp/header/any"><tt>&lt;any&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="variant.html" title="cpp/header/variant"><tt>&lt;variant&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="type_traits.html" title="cpp/header/type traits"><tt>&lt;type_traits&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="ratio.html" title="cpp/header/ratio"><tt>&lt;ratio&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="chrono.html" title="cpp/header/chrono"><tt>&lt;chrono&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="typeindex.html" title="cpp/header/typeindex"><tt>&lt;typeindex&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="functional.html" title="cpp/header/functional"><tt>&lt;functional&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="ctime.html" title="cpp/header/ctime"><tt>&lt;ctime&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cstdlib.html" title="cpp/header/cstdlib"><tt>&lt;cstdlib&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 字符串</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="string.html" title="cpp/header/string"><tt>&lt;string&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="string_view.html" title="cpp/header/string view"><tt>&lt;string_view&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cctype.html" title="cpp/header/cctype"><tt>&lt;cctype&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cwctype.html" title="cpp/header/cwctype"><tt>&lt;cwctype&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cwchar.html" title="cpp/header/cwchar"><tt>&lt;cwchar&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cuchar.html" title="cpp/header/cuchar"><tt>&lt;cuchar&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cstring.html" title="cpp/header/cstring"><tt>&lt;cstring&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="charconv.html" title="cpp/header/charconv"><tt>&lt;charconv&gt;</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 本地化</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="locale.html" title="cpp/header/locale"><tt>&lt;locale&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="codecvt.html" title="cpp/header/codecvt"><tt>&lt;codecvt&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="clocale.html" title="cpp/header/clocale"><tt>&lt;clocale&gt;</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 容器</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="span.html" title="cpp/header/span"><tt>&lt;span&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="array.html" title="cpp/header/array"><tt>&lt;array&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="vector.html" title="cpp/header/vector"><tt>&lt;vector&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="deque.html" title="cpp/header/deque"><tt>&lt;deque&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="forward_list.html" title="cpp/header/forward list"><tt>&lt;forward_list&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="list.html" title="cpp/header/list"><tt>&lt;list&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="map.html" title="cpp/header/map"><tt>&lt;map&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="set.html" title="cpp/header/set"><tt>&lt;set&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="queue.html" title="cpp/header/queue"><tt>&lt;queue&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="unordered_map.html" title="cpp/header/unordered map"><tt>&lt;unordered_map&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="unordered_set.html" title="cpp/header/unordered set"><tt>&lt;unordered_set&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="stack.html" title="cpp/header/stack"><tt>&lt;stack&gt;</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 迭代器</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="iterator.html" title="cpp/header/iterator"><tt>&lt;iterator&gt;</tt></a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 范围</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="ranges.html" title="cpp/header/ranges"><tt>&lt;ranges&gt;</tt></a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 算法</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <strong class="selflink"><tt>&lt;algorithm&gt;</tt></strong></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="execution.html" title="cpp/header/execution"><tt>&lt;execution&gt;</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 数值</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="complex.html" title="cpp/header/complex"><tt>&lt;complex&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="random.html" title="cpp/header/random"><tt>&lt;random&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="valarray.html" title="cpp/header/valarray"><tt>&lt;valarray&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="numeric.html" title="cpp/header/numeric"><tt>&lt;numeric&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="bit.html" title="cpp/header/bit"><tt>&lt;bit&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="numbers.html" title="cpp/header/numbers"><tt>&lt;numbers&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cfenv.html" title="cpp/header/cfenv"><tt>&lt;cfenv&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cmath.html" title="cpp/header/cmath"><tt>&lt;cmath&gt;</tt></a></td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 输入/输出</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="iosfwd.html" title="cpp/header/iosfwd"><tt>&lt;iosfwd&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="ios.html" title="cpp/header/ios"><tt>&lt;ios&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="iomanip.html" title="cpp/header/iomanip"><tt>&lt;iomanip&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="streambuf.html" title="cpp/header/streambuf"><tt>&lt;streambuf&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="istream.html" title="cpp/header/istream"><tt>&lt;istream&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="ostream.html" title="cpp/header/ostream"><tt>&lt;ostream&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="iostream.html" title="cpp/header/iostream"><tt>&lt;iostream&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="sstream.html" title="cpp/header/sstream"><tt>&lt;sstream&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="fstream.html" title="cpp/header/fstream"><tt>&lt;fstream&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="syncstream.html" title="cpp/header/syncstream"><tt>&lt;syncstream&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cstdio.html" title="cpp/header/cstdio"><tt>&lt;cstdio&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cinttypes.html" title="cpp/header/cinttypes"><tt>&lt;cinttypes&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="strstream.html" title="cpp/header/strstream"><tt>&lt;strstream&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 正则表达式</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="regex.html" title="cpp/header/regex"><tt>&lt;regex&gt;</tt></a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 文件系统</td></tr>
<tr class="t-nv"><td colspan="5"> <a href="filesystem.html" title="cpp/header/filesystem"><tt>&lt;filesystem&gt;</tt></a></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 线程支持</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="thread.html" title="cpp/header/thread"><tt>&lt;thread&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="atomic.html" title="cpp/header/atomic"><tt>&lt;atomic&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="mutex.html" title="cpp/header/mutex"><tt>&lt;mutex&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="shared_mutex.html" title="cpp/header/shared mutex"><tt>&lt;shared_mutex&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="condition_variable.html" title="cpp/header/condition variable"><tt>&lt;condition_variable&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="future.html" title="cpp/header/future"><tt>&lt;future&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/header/stop_token&amp;action=edit&amp;redlink=1" class="new" title="cpp/header/stop token（页面不存在）"><tt>&lt;stop_token&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/header/semaphore&amp;action=edit&amp;redlink=1" class="new" title="cpp/header/semaphore（页面不存在）"><tt>&lt;semaphore&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/header/latch&amp;action=edit&amp;redlink=1" class="new" title="cpp/header/latch（页面不存在）"><tt>&lt;latch&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/header/barrier&amp;action=edit&amp;redlink=1" class="new" title="cpp/header/barrier（页面不存在）"><tt>&lt;barrier&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> C 兼容</td></tr>
<tr class="t-nv-col-table"><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="ciso646.html" title="cpp/header/ciso646"><tt>&lt;ciso646&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="cstdalign.html" title="cpp/header/cstdalign"><tt>&lt;cstdalign&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="cstdbool.html" title="cpp/header/cstdbool"><tt>&lt;cstdbool&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <a href="ccomplex.html" title="cpp/header/ccomplex"><tt>&lt;ccomplex&gt;</tt></a></td></tr>
</table></div></td><td><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv"><td colspan="5"> <a href="ctgmath.html" title="cpp/header/ctgmath"><tt>&lt;ctgmath&gt;</tt></a></td></tr>
<tr class="t-nv"><td colspan="5"> <br>
</td></tr>
</table></div></td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div></div>
<p>此头文件是<a href="../algorithm.html" title="cpp/algorithm">算法</a>库的一部分。
</p>
<h3><span class="mw-headline" id=".E5.87.BD.E6.95.B0">函数</span></h3>
<table class="t-dsc-begin">

<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E4.B8.8D.E4.BF.AE.E6.94.B9.E5.BA.8F.E5.88.97.E7.9A.84.E6.93.8D.E4.BD.9C">  不修改序列的操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/all_any_none_of.html" title="cpp/algorithm/all any none of"> <span class="t-lines"><span>all_of</span><span>any_of</span><span>none_of</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   检查谓词是否对范围中所有、任一或无元素为 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span>  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/for_each.html" title="cpp/algorithm/for each"> <span class="t-lines"><span>for_each</span></span></a></div></div>
</td>
<td>   应用函数到范围中的元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/for_each_n.html" title="cpp/algorithm/for each n"> <span class="t-lines"><span>for_each_n</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div></div>
</td>
<td>   应用一个函数对象到序列的前 n 个元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/count_if.html" title="cpp/algorithm/count"> <span class="t-lines"><span>count</span><span>count_if</span></span></a></div></div>
</td>
<td>  返回满足指定判别标准的元素数 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/mismatch.html" title="cpp/algorithm/mismatch"> <span class="t-lines"><span>mismatch</span></span></a></div></div>
</td>
<td>   寻找两个范围出现不同的首个位置  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/find_if_not.html" title="cpp/algorithm/find"> <span class="t-lines"><span>find</span><span>find_if</span><span>find_if_not</span></span></a></div><div><span class="t-lines"><span></span><span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   寻找首个满足特定判别标准的元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/find_end.html" title="cpp/algorithm/find end"> <span class="t-lines"><span>find_end</span></span></a></div></div>
</td>
<td>   在特定范围中寻找最后出现的元素序列 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/find_first_of.html" title="cpp/algorithm/find first of"> <span class="t-lines"><span>find_first_of</span></span></a></div></div>
</td>
<td>   搜索元素集合中的任意元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/adjacent_find.html" title="cpp/algorithm/adjacent find"> <span class="t-lines"><span>adjacent_find</span></span></a></div></div>
</td>
<td>   查找首对相邻的相同（或满足给定谓词的）元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/search.html" title="cpp/algorithm/search"> <span class="t-lines"><span>search</span></span></a></div></div>
</td>
<td>   搜索一个元素范围  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/search_n.html" title="cpp/algorithm/search n"> <span class="t-lines"><span>search_n</span></span></a></div></div>
</td>
<td>   在范围中搜索一定量的某个元素的连续副本  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E4.BF.AE.E6.94.B9.E5.BA.8F.E5.88.97.E7.9A.84.E6.93.8D.E4.BD.9C">  修改序列的操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/copy.html" title="cpp/algorithm/copy"> <span class="t-lines"><span>copy</span><span>copy_if</span></span></a></div><div><span class="t-lines"><span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   将某一范围的元素复制到一个新的位置 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/copy_n.html" title="cpp/algorithm/copy n"> <span class="t-lines"><span>copy_n</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   将一定数目的元素复制到一个新的位置 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/copy_backward.html" title="cpp/algorithm/copy backward"> <span class="t-lines"><span>copy_backward</span></span></a></div></div>
</td>
<td>   按从后往前的顺序复制一个范围内的元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/move.html" title="cpp/algorithm/move"> <span class="t-lines"><span>move</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   将某一范围的元素移动到一个新的位置 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/move_backward.html" title="cpp/algorithm/move backward"> <span class="t-lines"><span>move_backward</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   按从后往前的顺序移动某一范围的元素到新的位置  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/fill.html" title="cpp/algorithm/fill"> <span class="t-lines"><span>fill</span></span></a></div></div>
</td>
<td>   将一个给定值复制赋值给一个范围内的每个元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/fill_n.html" title="cpp/algorithm/fill n"> <span class="t-lines"><span>fill_n</span></span></a></div></div>
</td>
<td>   将一个给定值复制赋值给一个范围内的 N 个元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/transform.html" title="cpp/algorithm/transform"> <span class="t-lines"><span>transform</span></span></a></div></div>
</td>
<td>   将一个函数应用于某一范围的各个元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/generate.html" title="cpp/algorithm/generate"> <span class="t-lines"><span>generate</span></span></a></div></div>
</td>
<td>  将相继的函数调用结果赋值给一个范围中的每个元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/generate_n.html" title="cpp/algorithm/generate n"> <span class="t-lines"><span>generate_n</span></span></a></div></div>
</td>
<td>  将相继的函数调用结果赋值给一个范围中的 N 个元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/remove.html" title="cpp/algorithm/remove"> <span class="t-lines"><span>remove</span><span>remove_if</span></span></a></div></div>
</td>
<td>  移除满足特定判别标准的元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/remove_copy.html" title="cpp/algorithm/remove copy"> <span class="t-lines"><span>remove_copy</span><span>remove_copy_if</span></span></a></div></div>
</td>
<td>   复制一个范围的元素，忽略满足特定判别标准的元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/replace.html" title="cpp/algorithm/replace"> <span class="t-lines"><span>replace</span><span>replace_if</span></span></a></div></div>
</td>
<td>   将所有满足特定判别标准的值替换为另一个值  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/replace_copy_if.html" title="cpp/algorithm/replace copy"> <span class="t-lines"><span>replace_copy</span><span>replace_copy_if</span></span></a></div></div>
</td>
<td>   复制一个范围内的元素，并将满足特定判别标准的元素替换为另一个值  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/swap.html" title="cpp/algorithm/swap"> <span class="t-lines"><span>swap</span></span></a></div></div>
</td>
<td>   交换两个对象的值  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/swap_ranges.html" title="cpp/algorithm/swap ranges"> <span class="t-lines"><span>swap_ranges</span></span></a></div></div>
</td>
<td>   交换两个范围的元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/iter_swap.html" title="cpp/algorithm/iter swap"> <span class="t-lines"><span>iter_swap</span></span></a></div></div>
</td>
<td>   交换两个迭代器所指向的元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/reverse.html" title="cpp/algorithm/reverse"> <span class="t-lines"><span>reverse</span></span></a></div></div>
</td>
<td>   逆转范围中的元素顺序  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/reverse_copy.html" title="cpp/algorithm/reverse copy"> <span class="t-lines"><span>reverse_copy</span></span></a></div></div>
</td>
<td>   创建一个范围的逆向副本  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/rotate.html" title="cpp/algorithm/rotate"> <span class="t-lines"><span>rotate</span></span></a></div></div>
</td>
<td>   旋转范围中的元素顺序  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/rotate_copy.html" title="cpp/algorithm/rotate copy"> <span class="t-lines"><span>rotate_copy</span></span></a></div></div>
</td>
<td>   复制并旋转元素范围 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/shift.html" title="cpp/algorithm/shift"> <span class="t-lines"><span>shift_left</span><span>shift_right</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div></div>
</td>
<td>  迁移范围中的元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/random_shuffle.html" title="cpp/algorithm/random shuffle"> <span class="t-lines"><span>random_shuffle</span><span>shuffle</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-until-cxx17">(C++17 前)</span></span><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   随机重排范围中的元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/sample.html" title="cpp/algorithm/sample"> <span class="t-lines"><span>sample</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div></div>
</td>
<td>   从一个序列中随机选择 n 个元素 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/unique.html" title="cpp/algorithm/unique"> <span class="t-lines"><span>unique</span></span></a></div></div>
</td>
<td>   移除范围内的连续重复元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/unique_copy.html" title="cpp/algorithm/unique copy"> <span class="t-lines"><span>unique_copy</span></span></a></div></div>
</td>
<td>   创建某范围的不含连续重复元素的副本  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E5.88.92.E5.88.86.E6.93.8D.E4.BD.9C">  划分操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/is_partitioned.html" title="cpp/algorithm/is partitioned"> <span class="t-lines"><span>is_partitioned</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   判断范围是否已按给定的谓词划分  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/partition.html" title="cpp/algorithm/partition"> <span class="t-lines"><span>partition</span></span></a></div></div>
</td>
<td>    将范围中的元素分为两组  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/partition_copy.html" title="cpp/algorithm/partition copy"> <span class="t-lines"><span>partition_copy</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   复制一个范围，将各元素分为两组  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/stable_partition.html" title="cpp/algorithm/stable partition"> <span class="t-lines"><span>stable_partition</span></span></a></div></div>
</td>
<td>   将元素分为两组，同时保留其相对顺序  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/partition_point.html" title="cpp/algorithm/partition point"> <span class="t-lines"><span>partition_point</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   定位已划分范围的划分点  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.8E.92.E5.BA.8F.E6.93.8D.E4.BD.9C">  排序操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/is_sorted.html" title="cpp/algorithm/is sorted"> <span class="t-lines"><span>is_sorted</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   检查范围是否已按升序排列  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/is_sorted_until.html" title="cpp/algorithm/is sorted until"> <span class="t-lines"><span>is_sorted_until</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>  找出最大的已排序子范围 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/sort.html" title="cpp/algorithm/sort"> <span class="t-lines"><span>sort</span></span></a></div></div>
</td>
<td>   将范围按升序排序  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/partial_sort.html" title="cpp/algorithm/partial sort"> <span class="t-lines"><span>partial_sort</span></span></a></div></div>
</td>
<td>   排序一个范围的前 N 个元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/partial_sort_copy.html" title="cpp/algorithm/partial sort copy"> <span class="t-lines"><span>partial_sort_copy</span></span></a></div></div>
</td>
<td>   对范围内的元素进行复制并部分排序  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/stable_sort.html" title="cpp/algorithm/stable sort"> <span class="t-lines"><span>stable_sort</span></span></a></div></div>
</td>
<td>   将范围内的元素排序，同时保持相等的元素之间的顺序  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/nth_element.html" title="cpp/algorithm/nth element"> <span class="t-lines"><span>nth_element</span></span></a></div></div>
</td>
<td>   将给定的范围部分排序，确保其按给定元素划分  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".EF.BC.88.E5.B7.B2.E6.8E.92.E5.BA.8F.E8.8C.83.E5.9B.B4.E4.B8.8A.E7.9A.84.EF.BC.89.E4.BA.8C.E5.88.86.E6.90.9C.E7.B4.A2.E6.93.8D.E4.BD.9C">  （已排序范围上的）二分搜索操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/lower_bound.html" title="cpp/algorithm/lower bound"> <span class="t-lines"><span>lower_bound</span></span></a></div></div>
</td>
<td>   返回指向第一个<i>不小于</i>给定值的元素的迭代器  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/upper_bound.html" title="cpp/algorithm/upper bound"> <span class="t-lines"><span>upper_bound</span></span></a></div></div>
</td>
<td>   返回指向第一个<i>大于</i>给定值的元素的迭代器  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/binary_search.html" title="cpp/algorithm/binary search"> <span class="t-lines"><span>binary_search</span></span></a></div></div>
</td>
<td>   确定元素是否存在于某范围中  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/equal_range.html" title="cpp/algorithm/equal range"> <span class="t-lines"><span>equal_range</span></span></a></div></div>
</td>
<td>   返回匹配特定键值的元素范围  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E5.85.B6.E4.BB.96.E5.B7.B2.E6.8E.92.E5.BA.8F.E8.8C.83.E5.9B.B4.E4.B8.8A.E7.9A.84.E6.93.8D.E4.BD.9C">  其他已排序范围上的操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/merge.html" title="cpp/algorithm/merge"> <span class="t-lines"><span>merge</span></span></a></div></div>
</td>
<td>   归并两个已排序的范围  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/inplace_merge.html" title="cpp/algorithm/inplace merge"> <span class="t-lines"><span>inplace_merge</span></span></a></div></div>
</td>
<td>   就地归并两个有序范围  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".EF.BC.88.E5.B7.B2.E6.8E.92.E5.BA.8F.E8.8C.83.E5.9B.B4.E4.B8.8A.E7.9A.84.EF.BC.89.E9.9B.86.E5.90.88.E6.93.8D.E4.BD.9C">  （已排序范围上的）集合操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/includes.html" title="cpp/algorithm/includes"> <span class="t-lines"><span>includes</span></span></a></div></div>
</td>
<td>   若一个集合是另一个的子集则返回 true  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/set_difference.html" title="cpp/algorithm/set difference"> <span class="t-lines"><span>set_difference</span></span></a></div></div>
</td>
<td>   计算两个集合的差集  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/set_intersection.html" title="cpp/algorithm/set intersection"> <span class="t-lines"><span>set_intersection</span></span></a></div></div>
</td>
<td>   计算两个集合的交集  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/set_symmetric_difference.html" title="cpp/algorithm/set symmetric difference"> <span class="t-lines"><span>set_symmetric_difference</span></span></a></div></div>
</td>
<td>   计算两个集合的对称差 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/set_union.html" title="cpp/algorithm/set union"> <span class="t-lines"><span>set_union</span></span></a></div></div>
</td>
<td>   计算两个集合的并集  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E5.A0.86.E6.93.8D.E4.BD.9C">  堆操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/is_heap.html" title="cpp/algorithm/is heap"> <span class="t-lines"><span>is_heap</span></span></a></div></div>
</td>
<td>   检查给定范围是否为一个最大堆  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/is_heap_until.html" title="cpp/algorithm/is heap until"> <span class="t-lines"><span>is_heap_until</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   查找能成为最大堆的最大子范围  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/make_heap.html" title="cpp/algorithm/make heap"> <span class="t-lines"><span>make_heap</span></span></a></div></div>
</td>
<td>   从一个元素范围创建出一个最大堆  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/push_heap.html" title="cpp/algorithm/push heap"> <span class="t-lines"><span>push_heap</span></span></a></div></div>
</td>
<td>   将一个元素加入到一个最大堆  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/pop_heap.html" title="cpp/algorithm/pop heap"> <span class="t-lines"><span>pop_heap</span></span></a></div></div>
</td>
<td>   从最大堆中移除最大元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/sort_heap.html" title="cpp/algorithm/sort heap"> <span class="t-lines"><span>sort_heap</span></span></a></div></div>
</td>
<td>   将一个最大堆变成一个按升序排序的元素范围  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.9C.80.E5.B0.8F.2F.E6.9C.80.E5.A4.A7.E6.93.8D.E4.BD.9C">  最小/最大操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/max.html" title="cpp/algorithm/max"> <span class="t-lines"><span>max</span></span></a></div></div>
</td>
<td>   返回各给定值中的较大者  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/max_element.html" title="cpp/algorithm/max element"> <span class="t-lines"><span>max_element</span></span></a></div></div>
</td>
<td>   返回范围内的最大元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/min.html" title="cpp/algorithm/min"> <span class="t-lines"><span>min</span></span></a></div></div>
</td>
<td>   返回各给定值中的较小者 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/min_element.html" title="cpp/algorithm/min element"> <span class="t-lines"><span>min_element</span></span></a></div></div>
</td>
<td>   返回范围内的最小元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/minmax.html" title="cpp/algorithm/minmax"> <span class="t-lines"><span>minmax</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>    返回两个元素的较小和较大者  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/minmax_element.html" title="cpp/algorithm/minmax element"> <span class="t-lines"><span>minmax_element</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   返回范围内的最小元素和最大元素  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/clamp.html" title="cpp/algorithm/clamp"> <span class="t-lines"><span>clamp</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx17">(C++17)</span></span></span></div></div>
</td>
<td>   在一对边界值间夹逼一个值  <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.AF.94.E8.BE.83.E6.93.8D.E4.BD.9C">  比较操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/equal.html" title="cpp/algorithm/equal"> <span class="t-lines"><span>equal</span></span></a></div></div>
</td>
<td>   确定两个元素集合是否是相同的  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/lexicographical_compare.html" title="cpp/algorithm/lexicographical compare"> <span class="t-lines"><span>lexicographical_compare</span></span></a></div></div>
</td>
<td>   当一个范围按字典顺序小于另一个范围时，返回 true  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/compare_3way.html" title="cpp/algorithm/compare 3way"> <span class="t-lines"><span>compare_3way</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div></div>
</td>
<td>  用三路比较比较两个值 <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/lexicographical_compare_3way.html" title="cpp/algorithm/lexicographical compare 3way"> <span class="t-lines"><span>lexicographical_compare_3way</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx20">(C++20)</span></span></span></div></div>
</td>
<td>  用三路比较比较两个范围 <br> <span class="t-mark">(函数模板)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.8E.92.E5.88.97.E6.93.8D.E4.BD.9C">  排列操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/is_permutation.html" title="cpp/algorithm/is permutation"> <span class="t-lines"><span>is_permutation</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div>
</td>
<td>   判断一个序列是否为另一个序列的排列  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/next_permutation.html" title="cpp/algorithm/next permutation"> <span class="t-lines"><span>next_permutation</span></span></a></div></div>
</td>
<td>   产生某个元素范围的按字典顺序的下一个较大的排列  <br> <span class="t-mark">(函数模板)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/prev_permutation.html" title="cpp/algorithm/prev permutation"> <span class="t-lines"><span>prev_permutation</span></span></a></div></div>
</td>
<td>   产生某个元素范围的按字典顺序的下一个较小的排列  <br> <span class="t-mark">(函数模板)</span> </td></tr>
</table>
<h3><span class="mw-headline" id="Niebloid">Niebloid</span></h3>
<table class="t-dsc-begin">

<tr class="t-dsc-header">
<td colspan="2"> <div>定义于命名空间 <code>std::ranges</code></div>
</td></tr>

<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E4.B8.8D.E4.BF.AE.E6.94.B9.E5.BA.8F.E5.88.97.E7.9A.84.E6.93.8D.E4.BD.9C_2">  不修改序列的操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="../algorithm/ranges/all_any_none_of.html" title="cpp/algorithm/ranges/all any none of"> <span class="t-lines"><span>all_of</span><span>any_of</span><span>none_of</span></span></a></div></div>
</td>
<td>  检查谓词是否对范围中所有、任一或无元素为 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="kw2">true</span></span></span> <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/for_each&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/for each（页面不存在）"> <span class="t-lines"><span>for_each</span></span></a></div></div>
</td>
<td>  应用函数到范围中的元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/count&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/count（页面不存在）"> <span class="t-lines"><span>count</span><span>count_if</span></span></a></div></div>
</td>
<td>  返回满足指定判别标准的元素数 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/mismatch&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/mismatch（页面不存在）"> <span class="t-lines"><span>mismatch</span></span></a></div></div>
</td>
<td>  寻找两个范围出现不同的首个位置 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/find&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/find（页面不存在）"> <span class="t-lines"><span>find</span><span>find_if</span><span>find_if_not</span></span></a></div></div>
</td>
<td>  寻找首个满足特定判别标准的元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/find_end&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/find end（页面不存在）"> <span class="t-lines"><span>find_end</span></span></a></div></div>
</td>
<td>  在特定范围中寻找最后出现的元素序列 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/find_first_of&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/find first of（页面不存在）"> <span class="t-lines"><span>find_first_of</span></span></a></div></div>
</td>
<td>  搜索元素集合中的任意元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/adjacent_find&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/adjacent find（页面不存在）"> <span class="t-lines"><span>adjacent_find</span></span></a></div></div>
</td>
<td>   查找首对相邻的相同（或满足给定谓词的）元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/search&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/search（页面不存在）"> <span class="t-lines"><span>search</span></span></a></div></div>
</td>
<td>  搜索一个元素范围  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/search_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/search n（页面不存在）"> <span class="t-lines"><span>search_n</span></span></a></div></div>
</td>
<td>  在范围中搜索一定量的某个元素的连续副本  <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E4.BF.AE.E6.94.B9.E5.BA.8F.E5.88.97.E7.9A.84.E6.93.8D.E4.BD.9C_2">  修改序列的操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/copy（页面不存在）"> <span class="t-lines"><span>copy</span><span>copy_if</span></span></a></div></div>
</td>
<td>  将某一范围的元素复制到一个新的位置  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/copy_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/copy n（页面不存在）"> <span class="t-lines"><span>copy_n</span></span></a></div></div>
</td>
<td>  将一定数目的元素复制到一个新的位置  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/copy_backward&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/copy backward（页面不存在）"> <span class="t-lines"><span>copy_backward</span></span></a></div></div>
</td>
<td>  按从后往前的顺序复制一个范围内的元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/move&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/move（页面不存在）"> <span class="t-lines"><span>move</span></span></a></div></div>
</td>
<td>  将某一范围的元素移动到一个新的位置  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/move_backward&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/move backward（页面不存在）"> <span class="t-lines"><span>move_backward</span></span></a></div></div>
</td>
<td>  按从后往前的顺序移动某一范围的元素到新的位置  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/fill&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/fill（页面不存在）"> <span class="t-lines"><span>fill</span></span></a></div></div>
</td>
<td>  将一个给定值复制赋值给一个范围内的每个元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/fill_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/fill n（页面不存在）"> <span class="t-lines"><span>fill_n</span></span></a></div></div>
</td>
<td>  将一个值复制赋值给一定量的元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/transform&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/transform（页面不存在）"> <span class="t-lines"><span>transform</span></span></a></div></div>
</td>
<td>  将一个函数应用于某一范围的各个元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/generate&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/generate（页面不存在）"> <span class="t-lines"><span>generate</span></span></a></div></div>
</td>
<td>  保存函数结果到一个范围中 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/generate_n&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/generate n（页面不存在）"> <span class="t-lines"><span>generate_n</span></span></a></div></div>
</td>
<td>  保存 N 次函数应用的结果 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/remove&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/remove（页面不存在）"> <span class="t-lines"><span>remove</span><span>remove_if</span></span></a></div></div>
</td>
<td>  移除满足特定判别标准的元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/remove_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/remove copy（页面不存在）"> <span class="t-lines"><span>remove_copy</span><span>remove_copy_if</span></span></a></div></div>
</td>
<td>  复制一个范围的元素，忽略满足特定判别标准的元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/replace&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/replace（页面不存在）"> <span class="t-lines"><span>replace</span><span>replace_if</span></span></a></div></div>
</td>
<td>  将所有满足特定判别标准的值替换为另一个值  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/replace_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/replace copy（页面不存在）"> <span class="t-lines"><span>replace_copy</span><span>replace_copy_if</span></span></a></div></div>
</td>
<td>  复制一个范围内的元素，并将满足特定判别标准的元素替换为另一个值 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/swap_ranges&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/swap ranges（页面不存在）"> <span class="t-lines"><span>swap_ranges</span></span></a></div></div>
</td>
<td>  交换两个范围的元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/reverse&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/reverse（页面不存在）"> <span class="t-lines"><span>reverse</span></span></a></div></div>
</td>
<td>  逆转范围中的元素顺序 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/reverse_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/reverse copy（页面不存在）"> <span class="t-lines"><span>reverse_copy</span></span></a></div></div>
</td>
<td>  创建一个范围的逆向副本  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/rotate&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/rotate（页面不存在）"> <span class="t-lines"><span>rotate</span></span></a></div></div>
</td>
<td>  旋转范围中的元素顺序 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/rotate_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/rotate copy（页面不存在）"> <span class="t-lines"><span>rotate_copy</span></span></a></div></div>
</td>
<td>  复制并旋转元素范围 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/shuffle&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/shuffle（页面不存在）"> <span class="t-lines"><span>shuffle</span></span></a></div></div>
</td>
<td>  随机重排范围中的元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/unique&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/unique（页面不存在）"> <span class="t-lines"><span>unique</span></span></a></div></div>
</td>
<td>  移除范围中的连续重复元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/unique_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/unique copy（页面不存在）"> <span class="t-lines"><span>unique_copy</span></span></a></div></div>
</td>
<td>  创建某范围的不含连续重复元素的副本 <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E5.88.92.E5.88.86.E6.93.8D.E4.BD.9C_2">  划分操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_partitioned&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is partitioned（页面不存在）"> <span class="t-lines"><span>is_partitioned</span></span></a></div></div>
</td>
<td>  判断范围是否已按给定的谓词划分  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partition&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partition（页面不存在）"> <span class="t-lines"><span>partition</span></span></a></div></div>
</td>
<td>  将范围中的元素分为二组 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partition_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partition copy（页面不存在）"> <span class="t-lines"><span>partition_copy</span></span></a></div></div>
</td>
<td>  复制一个范围，将各元素分为二组 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/stable_partition&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/stable partition（页面不存在）"> <span class="t-lines"><span>stable_partition</span></span></a></div></div>
</td>
<td>  将元素分成二组，同时保持其相对顺序 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partition_point&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partition point（页面不存在）"> <span class="t-lines"><span>partition_point</span></span></a></div></div>
</td>
<td>  定位已划分范围的划分点 <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.8E.92.E5.BA.8F.E6.93.8D.E4.BD.9C_2">  排序操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_sorted&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is sorted（页面不存在）"> <span class="t-lines"><span>is_sorted</span></span></a></div></div>
</td>
<td>  检查范围是否以升序排序 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_sorted_until&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is sorted until（页面不存在）"> <span class="t-lines"><span>is_sorted_until</span></span></a></div></div>
</td>
<td>  寻找最大的已排序子范围 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/sort&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/sort（页面不存在）"> <span class="t-lines"><span>sort</span></span></a></div></div>
</td>
<td>  将范围按升序排序  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partial_sort&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partial sort（页面不存在）"> <span class="t-lines"><span>partial_sort</span></span></a></div></div>
</td>
<td>  排序一个范围的前 N 个元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/partial_sort_copy&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/partial sort copy（页面不存在）"> <span class="t-lines"><span>partial_sort_copy</span></span></a></div></div>
</td>
<td>  对范围内的元素进行复制并部分排序  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/stable_sort&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/stable sort（页面不存在）"> <span class="t-lines"><span>stable_sort</span></span></a></div></div>
</td>
<td>  将范围内的元素排序，同时保持相等的元素之间的顺序  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/nth_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/nth element（页面不存在）"> <span class="t-lines"><span>nth_element</span></span></a></div></div>
</td>
<td>  将给定的范围部分排序，确保其按给定元素划分  <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".EF.BC.88.E5.B7.B2.E6.8E.92.E5.BA.8F.E8.8C.83.E5.9B.B4.E4.B8.8A.E7.9A.84.EF.BC.89.E9.9B.86.E5.90.88.E6.93.8D.E4.BD.9C_2">  （已排序范围上的）集合操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/lower_bound&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/lower bound（页面不存在）"> <span class="t-lines"><span>lower_bound</span></span></a></div></div>
</td>
<td>  返回指向首个<i>不小于</i>给定值的元素的迭代器 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/upper_bound&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/upper bound（页面不存在）"> <span class="t-lines"><span>upper_bound</span></span></a></div></div>
</td>
<td>  返回指向首个<i>大于</i>某值的元素的迭代器 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/binary_search&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/binary search（页面不存在）"> <span class="t-lines"><span>binary_search</span></span></a></div></div>
</td>
<td>  确定元素是否存在于某范围中 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/equal_range&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/equal range（页面不存在）"> <span class="t-lines"><span>equal_range</span></span></a></div></div>
</td>
<td>  返回匹配特定键值的元素范围  <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E5.85.B6.E4.BB.96.E5.B7.B2.E6.8E.92.E5.BA.8F.E8.8C.83.E5.9B.B4.E4.B8.8A.E7.9A.84.E6.93.8D.E4.BD.9C_2">  其他已排序范围上的操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/merge&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/merge（页面不存在）"> <span class="t-lines"><span>merge</span></span></a></div></div>
</td>
<td>  归并二个已排序范围 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/inplace_merge&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/inplace merge（页面不存在）"> <span class="t-lines"><span>inplace_merge</span></span></a></div></div>
</td>
<td>  在原位归并两个有序范围 <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".EF.BC.88.E5.B7.B2.E6.8E.92.E5.BA.8F.E8.8C.83.E5.9B.B4.E4.B8.8A.E7.9A.84.EF.BC.89.E9.9B.86.E5.90.88.E6.93.8D.E4.BD.9C_3">  （已排序范围上的）集合操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/includes&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/includes（页面不存在）"> <span class="t-lines"><span>includes</span></span></a></div></div>
</td>
<td>  若一个集合是另一个的子集则返回 <code>true</code> <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_difference&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set difference（页面不存在）"> <span class="t-lines"><span>set_difference</span></span></a></div></div>
</td>
<td>  计算两个集合的差集  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_intersection&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set intersection（页面不存在）"> <span class="t-lines"><span>set_intersection</span></span></a></div></div>
</td>
<td>  计算两个集合的交集  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_symmetric_difference&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set symmetric difference（页面不存在）"> <span class="t-lines"><span>set_symmetric_difference</span></span></a></div></div>
</td>
<td>  计算两个集合的对称差  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/set_union&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/set union（页面不存在）"> <span class="t-lines"><span>set_union</span></span></a></div></div>
</td>
<td>  计算两个集合的并集  <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E5.A0.86.E6.93.8D.E4.BD.9C_2">  堆操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is heap（页面不存在）"> <span class="t-lines"><span>is_heap</span></span></a></div></div>
</td>
<td>  检查给定范围是否为最大堆 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_heap_until&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is heap until（页面不存在）"> <span class="t-lines"><span>is_heap_until</span></span></a></div></div>
</td>
<td>  寻找能成为最大堆的最大子范围 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/make_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/make heap（页面不存在）"> <span class="t-lines"><span>make_heap</span></span></a></div></div>
</td>
<td>  从一个元素范围创建出一个最大堆  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/push_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/push heap（页面不存在）"> <span class="t-lines"><span>push_heap</span></span></a></div></div>
</td>
<td>  将一个元素加入到一个最大堆  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/pop_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/pop heap（页面不存在）"> <span class="t-lines"><span>pop_heap</span></span></a></div></div>
</td>
<td>  从最大堆中移除最大元素  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/sort_heap&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/sort heap（页面不存在）"> <span class="t-lines"><span>sort_heap</span></span></a></div></div>
</td>
<td>  将一个最大堆变成一个按升序排序的元素范围  <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.9C.80.E5.B0.8F.2F.E6.9C.80.E5.A4.A7.E6.93.8D.E4.BD.9C_2">  最小/最大操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/max&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/max（页面不存在）"> <span class="t-lines"><span>max</span></span></a></div></div>
</td>
<td>  返回给定值的较大者 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/max_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/max element（页面不存在）"> <span class="t-lines"><span>max_element</span></span></a></div></div>
</td>
<td>  返回范围中的最大元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/min&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/min（页面不存在）"> <span class="t-lines"><span>min</span></span></a></div></div>
</td>
<td>  返回给定值的较小者 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/min_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/min element（页面不存在）"> <span class="t-lines"><span>min_element</span></span></a></div></div>
</td>
<td>  返回范围中的最小元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/minmax&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/minmax（页面不存在）"> <span class="t-lines"><span>minmax</span></span></a></div></div>
</td>
<td>  返回两个元素的较小和较大者 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/minmax_element&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/minmax element（页面不存在）"> <span class="t-lines"><span>minmax_element</span></span></a></div></div>
</td>
<td>  返回范围中的最小和最大元素 <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.AF.94.E8.BE.83.E6.93.8D.E4.BD.9C_2">  比较操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/equal&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/equal（页面不存在）"> <span class="t-lines"><span>equal</span></span></a></div></div>
</td>
<td>  确定两个元素集合是否是相同的  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/lexicographical_compare&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/lexicographical compare（页面不存在）"> <span class="t-lines"><span>lexicographical_compare</span></span></a></div></div>
</td>
<td>  当一个范围按字典顺序小于另一个范围时，返回 true  <br> <span class="t-mark">(niebloid)</span> </td></tr>


<tr>
<td colspan="2"> <h5> <span class="mw-headline" id=".E6.8E.92.E5.88.97.E6.93.8D.E4.BD.9C_2">  排列操作 </span></h5>
</td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/is_permutation&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/is permutation（页面不存在）"> <span class="t-lines"><span>is_permutation</span></span></a></div></div>
</td>
<td>  确定一个序列是否为另一序列的重排 <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/next_permutation&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/next permutation（页面不存在）"> <span class="t-lines"><span>next_permutation</span></span></a></div></div>
</td>
<td>  产生某个元素范围的按字典序下一个较大的排列  <br> <span class="t-mark">(niebloid)</span> </td></tr>

<tr class="t-dsc">
<td>  <div class="t-dsc-member-div"><div><a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/algorithm/ranges/prev_permutation&amp;action=edit&amp;redlink=1" class="new" title="cpp/algorithm/ranges/prev permutation（页面不存在）"> <span class="t-lines"><span>prev_permutation</span></span></a></div></div>
</td>
<td>  产生某个元素范围的按字典序下一个较小的排列 <br> <span class="t-mark">(niebloid)</span> </td></tr>
</table>
<h3><span class="mw-headline" id=".E6.A6.82.E8.A6.81">概要</span></h3>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;initializer_list&gt;</span>
 
<span class="kw1">namespace</span> std <span class="br0">{</span>
  <span class="co1">// 不修改序列的操作：</span>
  <span class="co1">// 全部（all of）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> all_of<span class="br0">(</span>InputIt first, InputIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> all_of<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> all_of<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> all_of<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 任一（any of）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> any_of<span class="br0">(</span>InputIt first, InputIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> any_of<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> any_of<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> any_of<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 无一（none of）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> none_of<span class="br0">(</span>InputIt first, InputIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> none_of<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                 ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> none_of<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> none_of<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 对每元素（for each）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Function<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> Function for_each<span class="br0">(</span>InputIt first, InputIt last, Function f<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Function<span class="sy1">&gt;</span>
    <span class="kw4">void</span> for_each<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt first, ForwardIt last, Function f<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> F<span class="sy1">&gt;</span>
    <span class="kw1">struct</span> for_each_result <span class="br0">{</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> I in<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> F fun<span class="sy4">;</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I2, <span class="kw1">class</span> F2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> I<span class="sy3">&amp;</span>, I2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> F<span class="sy3">&amp;</span>, F2<span class="sy1">&gt;</span>
        operator for_each_result<span class="sy1">&lt;</span>I2, F2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="sy3">&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>in, fun<span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I2, <span class="kw1">class</span> F2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span>I, I2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span>F, F2<span class="sy1">&gt;</span>
        operator for_each_result<span class="sy1">&lt;</span>I2, F2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>in<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>fun<span class="br0">)</span><span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryInvocable<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Fun<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> for_each_result<span class="sy1">&lt;</span>I, Fun<span class="sy1">&gt;</span>
        for_each<span class="br0">(</span>I first, S last, Fun f, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryInvocable<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Fun<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> for_each_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Fun<span class="sy1">&gt;</span>
        for_each<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Fun f, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> Function<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> InputIt for_each_n<span class="br0">(</span>InputIt first, Size n, Function f<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> Function<span class="sy1">&gt;</span>
    ForwardIt for_each_n<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                         ForwardIt first, Size n, Function f<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="co1">// 寻找（find）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> InputIt find<span class="br0">(</span>InputIt first, InputIt last,
                           <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    ForwardIt find<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                   ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> InputIt find_if<span class="br0">(</span>InputIt first, InputIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    ForwardIt find_if<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                      ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> InputIt find_if_not<span class="br0">(</span>InputIt first, InputIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    ForwardIt find_if_not<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                          ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I find<span class="br0">(</span>I first, S last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        find<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I find_if<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        find_if<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I find_if_not<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        find_if_not<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 寻找末尾（find end）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt1
      find_end<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt1
      find_end<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt1
      find_end<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1,
           <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    ForwardIt1
      find_end<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, ForwardIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>I1, I2, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> subrange<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span>
        find_end<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                 Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R1, ForwardRange R2,
             <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_subrange_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>
        find_end<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                 Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 寻找首个（find first）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> InputIt
      find_first_of<span class="br0">(</span>InputIt first1, InputIt last1, ForwardIt first2, ForwardIt last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> InputIt
      find_first_of<span class="br0">(</span>InputIt first1, InputIt last1, ForwardIt first2, ForwardIt last2,
                    BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt1
      find_first_of<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    ForwardIt1
      find_first_of<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    ForwardIt1 first1, ForwardIt1 last1,
                    ForwardIt2 first2, ForwardIt2 last2,
                    BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, ForwardIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I1, Proj1<span class="sy1">&gt;</span>,
                              projected<span class="sy1">&lt;</span>I2, Proj2<span class="sy1">&gt;&gt;</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I1 find_first_of<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2,
                                 Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                 Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, ForwardRange R2,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, Proj1<span class="sy1">&gt;</span>,
                              projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Proj2<span class="sy1">&gt;&gt;</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>
        find_first_of<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2,
                      Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                      Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 毗邻寻找（adjacent find）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      adjacent_find<span class="br0">(</span>ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      adjacent_find<span class="br0">(</span>ForwardIt first, ForwardIt last, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      adjacent_find<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    ForwardIt
      adjacent_find<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    ForwardIt first, ForwardIt last, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I adjacent_find<span class="br0">(</span>I first, S last, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        adjacent_find<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 计数（count）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>InputIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span>
      count<span class="br0">(</span>InputIt first, InputIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>ForwardIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span>
      count<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
            ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>InputIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span>
      count_if<span class="br0">(</span>InputIt first, InputIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>ForwardIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span>
      count_if<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> iter_difference_t<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>
        count<span class="br0">(</span>I first, S last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> iter_difference_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
        count<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> iter_difference_t<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>
        count_if<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> iter_difference_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
        count_if<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 不匹配（mismatch）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>InputIt1, InputIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>InputIt1, InputIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>InputIt1, InputIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>InputIt1, InputIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
               BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    pair<span class="sy1">&lt;</span>ForwardIt1, ForwardIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    pair<span class="sy1">&lt;</span>ForwardIt1, ForwardIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    pair<span class="sy1">&lt;</span>ForwardIt1, ForwardIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    pair<span class="sy1">&lt;</span>ForwardIt1, ForwardIt2<span class="sy1">&gt;</span>
      mismatch<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2<span class="sy1">&gt;</span>
    <span class="kw1">struct</span> mismatch_result <span class="br0">{</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> I1 in1<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> I2 in2<span class="sy4">;</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> II1, <span class="kw1">class</span> II2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> I1<span class="sy3">&amp;</span>, II1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> I2<span class="sy3">&amp;</span>, II2<span class="sy1">&gt;</span>
        operator mismatch_result<span class="sy1">&lt;</span>II1, II2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="sy3">&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>in1, in2<span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> II1, <span class="kw1">class</span> II2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span>I1, II1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span>I2, II2<span class="sy1">&gt;</span>
        operator mismatch_result<span class="sy1">&lt;</span>II1, II2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>in1<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>in2<span class="br0">)</span><span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I1, Proj1<span class="sy1">&gt;</span>,
                              projected<span class="sy1">&lt;</span>I2, Proj2<span class="sy1">&gt;&gt;</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> mismatch_result<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span>
        mismatch<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                 Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, Proj1<span class="sy1">&gt;</span>,
                              projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Proj2<span class="sy1">&gt;&gt;</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> mismatch_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;&gt;</span>
        mismatch<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                 Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 相等（equal）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> equal<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> equal<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2,
                         BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> equal<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> equal<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                         BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> equal<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> equal<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> equal<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> equal<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
               BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>I1, I2, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> equal<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2,
                           Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                           Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> equal<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                           Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 是否为排列（is permutation）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_permutation<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_permutation<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2,
                                  BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_permutation<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1,
                                  ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_permutation<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1,
                                  ForwardIt2 first2, ForwardIt2 last2,
                                  BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, ForwardIterator I2,
             Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2, <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity,
             <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>I1, I2, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_permutation<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2,
                                    Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                    Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R1, ForwardRange R2, <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_permutation<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                    Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 搜索（search）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt1
      search<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt1
      search<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
             BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt1
      search<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
             ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    ForwardIt1
      search<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
             ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
             BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, ForwardIterator I2,
             Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2, <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>I1, I2, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> subrange<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span>
        search<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
               Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R1, ForwardRange R2, <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Pred, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_subrange_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>
        search<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
               Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      search_n<span class="br0">(</span>ForwardIt first, ForwardIt last, Size count, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> T, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      search_n<span class="br0">(</span>ForwardIt first, ForwardIt last,
               Size count, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    ForwardIt
      search_n<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt first, ForwardIt last, Size count, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> T, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    ForwardIt
      search_n<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
               ForwardIt first, ForwardIt last,
               Size count, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T,
             <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>I, <span class="kw4">const</span> T<span class="sy2">*</span>, Pred, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> subrange<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>
        search_n<span class="br0">(</span>I first, S last, iter_difference_t<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> count,
                 <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Pred <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyComparable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span>, Pred, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_subrange_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        search_n<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, iter_difference_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span> count,
                 <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Pred pred <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Searcher<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      search<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> Searcher<span class="sy3">&amp;</span> searcher<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="co1">// 修改序列的操作：</span>
  <span class="co1">// 复制（copy）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt copy<span class="br0">(</span>InputIt first, InputIt last, OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt2 copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    ForwardIt1 first, ForwardIt1 last, ForwardIt2 result<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">struct</span> copy_result <span class="br0">{</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> I in<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> O out<span class="sy4">;</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I2, <span class="kw1">class</span> O2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> I<span class="sy3">&amp;</span>, I2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> O<span class="sy3">&amp;</span>, O2<span class="sy1">&gt;</span>
        operator copy_result<span class="sy1">&lt;</span>I2, O2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="sy3">&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>in, out<span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I2, <span class="kw1">class</span> O2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span>I, I2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span>O, O2<span class="sy1">&gt;</span>
        operator copy_result<span class="sy1">&lt;</span>I2, O2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>in<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>out<span class="br0">)</span><span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        copy<span class="br0">(</span>I first, S last, O result<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> copy_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        copy<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt copy_n<span class="br0">(</span>InputIt first, Size n, OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> Size, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt2 copy_n<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                      ForwardIt1 first, Size n, ForwardIt2 result<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> copy_n_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> copy_n_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        copy_n<span class="br0">(</span>I first, iter_difference_t<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> n, O result<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt copy_if<span class="br0">(</span>InputIt first, InputIt last, OutputIt result, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    ForwardIt2 copy_if<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                       ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> copy_if_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> copy_if_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        copy_if<span class="br0">(</span>I first, S last, O result, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> copy_if_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        copy_if<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt1, <span class="kw1">class</span> BidirectionalIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> BidirectionalIt2
      copy_backward<span class="br0">(</span>BidirectionalIt1 first, BidirectionalIt1 last,
                    BidirectionalIt2 result<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2<span class="sy1">&gt;</span>
    <span class="kw1">using</span> copy_backward_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, BidirectionalIterator I2<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> copy_backward_result<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span>
        copy_backward<span class="br0">(</span>I1 first, S1 last, I2 result<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R, BidirectionalIterator I<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, I<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> copy_backward_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, I<span class="sy1">&gt;</span>
        copy_backward<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, I result<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 移动（move）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt move<span class="br0">(</span>InputIt first, InputIt last, OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt2 move<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    ForwardIt1 first, ForwardIt1 last, ForwardIt2 result<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> move_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyMovable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> move_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        move<span class="br0">(</span>I first, S last, O result<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyMovable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> move_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        move<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt1, <span class="kw1">class</span> BidirectionalIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> BidirectionalIt2
      move_backward<span class="br0">(</span>BidirectionalIt1 first, BidirectionalIt1 last,
                    BidirectionalIt2 result<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2<span class="sy1">&gt;</span>
    <span class="kw1">using</span> move_backward_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, BidirectionalIterator I2<span class="sy1">&gt;</span>
      requires IndirectlyMovable<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> move_backward_result<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span>
        move_backward<span class="br0">(</span>I1 first, S1 last, I2 result<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R, BidirectionalIterator I<span class="sy1">&gt;</span>
      requires IndirectlyMovable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, I<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> move_backward_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, I<span class="sy1">&gt;</span>
        move_backward<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, I result<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 交换（swap）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt2 swap_ranges<span class="br0">(</span>ForwardIt1 first1, ForwardIt1 last1,
                                     ForwardIt2 first2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt2 swap_ranges<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                           ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2<span class="sy1">&gt;</span>
    <span class="kw1">using</span> swap_ranges_result <span class="sy1">=</span> mismatch_result<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2<span class="sy1">&gt;</span>
      requires IndirectlySwappable<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> swap_ranges_result<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span>
        swap_ranges<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2<span class="sy1">&gt;</span>
      requires IndirectlySwappable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> swap_ranges_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;&gt;</span>
        swap_ranges<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> iter_swap<span class="br0">(</span>ForwardIt1 a, ForwardIt2 b<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="co1">// 变换（transform）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> UnaryOperation<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      transform<span class="br0">(</span>InputIt first1, InputIt last1, OutputIt result, UnaryOperation op<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> BinaryOperation<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      transform<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt result,
                BinaryOperation binary_op<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> UnaryOperation<span class="sy1">&gt;</span>
    ForwardIt2
      transform<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 result, UnaryOperation op<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> BinaryOperation<span class="sy1">&gt;</span>
    ForwardIt
      transform<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt result,
                BinaryOperation binary_op<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> unary_transform_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O,
             CopyConstructible F, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>O, indirect_result_t<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;&gt;</span>
      <span class="kw4">constexpr</span> unary_transform_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        transform<span class="br0">(</span>I first1, S last1, O result, F op, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O, CopyConstructible F,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>O, indirect_result_t<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;&gt;</span>
      <span class="kw4">constexpr</span> unary_transform_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        transform<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result, F op, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">struct</span> binary_transform_result <span class="br0">{</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> I1 in1<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> I2 in2<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> O  out<span class="sy4">;</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> II1, <span class="kw1">class</span> II2, <span class="kw1">class</span> OO<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> I1<span class="sy3">&amp;</span>, II1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
          ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> I2<span class="sy3">&amp;</span>, II2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> O<span class="sy3">&amp;</span>, OO<span class="sy1">&gt;</span>
        operator binary_transform_result<span class="sy1">&lt;</span>II1, II2, OO<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="sy3">&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>in1, in2, out<span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> II1, <span class="kw1">class</span> II2, <span class="kw1">class</span> OO<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span>I1, II1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
          ConvertibleTo<span class="sy1">&lt;</span>I2, II2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span>O, OO<span class="sy1">&gt;</span>
        operator binary_transform_result<span class="sy1">&lt;</span>II1, II2, OO<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>in1<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>in2<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>out<span class="br0">)</span><span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             WeaklyIncrementable O, CopyConstructible F, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity,
             <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>O, indirect_result_t<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span>, projected<span class="sy1">&lt;</span>I1, Proj1<span class="sy1">&gt;</span>,
                                             projected<span class="sy1">&lt;</span>I2, Proj2<span class="sy1">&gt;&gt;&gt;</span>
      <span class="kw4">constexpr</span> binary_transform_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span>
        transform<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, O result,
                  F binary_op, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, WeaklyIncrementable O,
             CopyConstructible F, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>O, indirect_result_t<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, Proj1<span class="sy1">&gt;</span>,
                                             projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Proj2<span class="sy1">&gt;&gt;&gt;</span>
      <span class="kw4">constexpr</span> binary_transform_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        transform<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, O result,
                  F binary_op, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 替换（replace）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> replace<span class="br0">(</span>ForwardIt first, ForwardIt last,
                           <span class="kw4">const</span> T<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">void</span> replace<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                 ForwardIt first, ForwardIt last,
                 <span class="kw4">const</span> T<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> replace_if<span class="br0">(</span>ForwardIt first, ForwardIt last,
                              Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">void</span> replace_if<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    ForwardIt first, ForwardIt last,
                    Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T1, <span class="kw1">class</span> T2, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>I, <span class="kw4">const</span> T2<span class="sy3">&amp;</span><span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T1<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        replace<span class="br0">(</span>I first, S last, <span class="kw4">const</span> T1<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T2<span class="sy3">&amp;</span> new_value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> T1, <span class="kw1">class</span> T2, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, <span class="kw4">const</span> T2<span class="sy3">&amp;</span><span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;</span>,
                 <span class="kw4">const</span> T1<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        replace<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T1<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T2<span class="sy3">&amp;</span> new_value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>I, <span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I replace_if<span class="br0">(</span>I first, S last,
                             Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires Writable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        replace_if<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt replace_copy<span class="br0">(</span>InputIt first, InputIt last, OutputIt result,
                                    <span class="kw4">const</span> T<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    ForwardIt2 replace_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                            ForwardIt1 first, ForwardIt1 last, ForwardIt2 result,
                            <span class="kw4">const</span> T<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Pred, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt replace_copy_if<span class="br0">(</span>InputIt first, InputIt last, OutputIt result,
                                       Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> Pred, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    ForwardIt2 replace_copy_if<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                               ForwardIt1 first, ForwardIt1 last, ForwardIt2 result,
                               Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> replace_copy_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T1, <span class="kw1">class</span> T2,
             OutputIterator<span class="sy1">&lt;</span><span class="kw4">const</span> T2<span class="sy3">&amp;</span><span class="sy1">&gt;</span> O, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T1<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> replace_copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        replace_copy<span class="br0">(</span>I first, S last, O result, <span class="kw4">const</span> T1<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T2<span class="sy3">&amp;</span> new_value,
                     Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> T1, <span class="kw1">class</span> T2, OutputIterator<span class="sy1">&lt;</span><span class="kw4">const</span> T2<span class="sy3">&amp;</span><span class="sy1">&gt;</span> O,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;</span>,
                 <span class="kw4">const</span> T1<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> replace_copy_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        replace_copy<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result, <span class="kw4">const</span> T1<span class="sy3">&amp;</span> old_value, <span class="kw4">const</span> T2<span class="sy3">&amp;</span> new_value,
                     Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> replace_copy_if_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, OutputIterator<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span> O,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity, IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> replace_copy_if_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        replace_copy_if<span class="br0">(</span>I first, S last, O result, Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value,
                        Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> T, OutputIterator<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span> O, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> replace_copy_if_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        replace_copy_if<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result, Pred pred, <span class="kw4">const</span> T<span class="sy3">&amp;</span> new_value,
                        Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 填充（fill）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> fill<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">void</span> fill<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
              ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt fill_n<span class="br0">(</span>OutputIt first, Size n, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    ForwardIt fill_n<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, Size n, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, OutputIterator<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span> O, Sentinel<span class="sy1">&lt;</span>O<span class="sy1">&gt;</span> S<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> O fill<span class="br0">(</span>O first, S last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, OutputRange<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span> R<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> fill<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, OutputIterator<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span> O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> O fill_n<span class="br0">(</span>O first, iter_difference_t<span class="sy1">&lt;</span>O<span class="sy1">&gt;</span> n, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 生成（generate）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Generator<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> generate<span class="br0">(</span>ForwardIt first, ForwardIt last, Generator gen<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Generator<span class="sy1">&gt;</span>
    <span class="kw4">void</span> generate<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt first, ForwardIt last, Generator gen<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> Generator<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt generate_n<span class="br0">(</span>OutputIt first, Size n, Generator gen<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Size, <span class="kw1">class</span> Generator<span class="sy1">&gt;</span>
    ForwardIt generate_n<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                         ForwardIt first, Size n, Generator gen<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Iterator O, Sentinel<span class="sy1">&lt;</span>O<span class="sy1">&gt;</span> S, CopyConstructible F<span class="sy1">&gt;</span>
      requires Invocable<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span><span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Writable<span class="sy1">&lt;</span>O, invoke_result_t<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span><span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> O generate<span class="br0">(</span>O first, S last, F gen<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> R, CopyConstructible F<span class="sy1">&gt;</span>
      requires Invocable<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span><span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> OutputRange<span class="sy1">&lt;</span>R, invoke_result_t<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span><span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> generate<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, F gen<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Iterator O, CopyConstructible F<span class="sy1">&gt;</span>
      requires Invocable<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span><span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Writable<span class="sy1">&lt;</span>O, invoke_result_t<span class="sy1">&lt;</span>F<span class="sy3">&amp;</span><span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> O generate_n<span class="br0">(</span>O first, iter_difference_t<span class="sy1">&lt;</span>O<span class="sy1">&gt;</span> n, F gen<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 移除（remove）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt remove<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    ForwardIt remove<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt remove_if<span class="br0">(</span>ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    ForwardIt remove_if<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                        ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Permutable I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I remove<span class="br0">(</span>I first, S last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        remove<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Permutable I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I remove_if<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        remove_if<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      remove_copy<span class="br0">(</span>InputIt first, InputIt last, OutputIt result, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    ForwardIt2
      remove_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      remove_copy_if<span class="br0">(</span>InputIt first, InputIt last, OutputIt result, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    ForwardIt2
      remove_copy_if<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> remove_copy_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O, <span class="kw1">class</span> T,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> remove_copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        remove_copy<span class="br0">(</span>I first, S last, O result, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectRelation<span class="sy1">&lt;</span>ranges<span class="sy4">::</span><span class="me2">equal_to</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;</span>, <span class="kw4">const</span> T<span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> remove_copy_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        remove_copy<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> remove_copy_if_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity, IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> remove_copy_if_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        remove_copy_if<span class="br0">(</span>I first, S last, O result, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> remove_copy_if_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        remove_copy_if<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 唯一（unique）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt unique<span class="br0">(</span>ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt unique<span class="br0">(</span>ForwardIt first, ForwardIt last, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt unique<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    ForwardIt unique<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, ForwardIt last, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Permutable I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> C <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I unique<span class="br0">(</span>I first, S last, C comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> C <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        unique<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, C comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      unique_copy<span class="br0">(</span>InputIt first, InputIt last, OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      unique_copy<span class="br0">(</span>InputIt first, InputIt last, OutputIt result, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt2
      unique_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt1 first, ForwardIt1 last, ForwardIt2 result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> BinaryPred<span class="sy1">&gt;</span>
    ForwardIt2
      unique_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt1 first, ForwardIt1 last, ForwardIt2 result, BinaryPred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> unique_copy_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> C <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               <span class="br0">(</span>ForwardIterator<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> <span class="sy3">||</span>
                <span class="br0">(</span>InputIterator<span class="sy1">&lt;</span>O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Same<span class="sy1">&lt;</span>iter_value_t<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>, iter_value_t<span class="sy1">&lt;</span>O<span class="sy1">&gt;&gt;</span><span class="br0">)</span> <span class="sy3">||</span>
                IndirectlyCopyableStorable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="br0">)</span>
      <span class="kw4">constexpr</span> unique_copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        unique_copy<span class="br0">(</span>I first, S last, O result, C comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectRelation<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> C <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">equal_to</span><span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               <span class="br0">(</span>ForwardIterator<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span> <span class="sy3">||</span>
                <span class="br0">(</span>InputIterator<span class="sy1">&lt;</span>O<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Same<span class="sy1">&lt;</span>iter_value_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>, iter_value_t<span class="sy1">&lt;</span>O<span class="sy1">&gt;&gt;</span><span class="br0">)</span> <span class="sy3">||</span>
                IndirectlyCopyableStorable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span><span class="br0">)</span>
      <span class="kw4">constexpr</span> unique_copy_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        unique_copy<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result, C comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 反转（reverse）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> reverse<span class="br0">(</span>BidirectionalIt first, BidirectionalIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> BidirectionalIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> reverse<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                 BidirectionalIt first, BidirectionalIt last<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I reverse<span class="br0">(</span>I first, S last<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> reverse<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      reverse_copy<span class="br0">(</span>BidirectionalIt first, BidirectionalIt last, OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      reverse_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                   BidirectionalIt first, BidirectionalIt last, ForwardIt result<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> reverse_copy_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> reverse_copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        reverse_copy<span class="br0">(</span>I first, S last, O result<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> reverse_copy_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        reverse_copy<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O result<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 旋转（rotate）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt rotate<span class="br0">(</span>ForwardIt first, ForwardIt middle, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt rotate<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, ForwardIt middle, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Permutable I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> subrange<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> rotate<span class="br0">(</span>I first, I middle, S last<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> safe_subrange_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> rotate<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> middle<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      rotate_copy<span class="br0">(</span>ForwardIt first, ForwardIt middle, ForwardIt last, OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    ForwardIt2
      rotate_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt1 first, ForwardIt1 middle, ForwardIt1 last, ForwardIt2 result<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> rotate_copy_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> rotate_copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span>
        rotate_copy<span class="br0">(</span>I first, I middle, S last, O result<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, WeaklyIncrementable O<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> rotate_copy_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        rotate_copy<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> middle, O result<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 采样（sample）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> PopulationIt, <span class="kw1">class</span> SampleIt,
           <span class="kw1">class</span> Distance, <span class="kw1">class</span> UniformRndBitGen<span class="sy1">&gt;</span>
    SampleIt sample<span class="br0">(</span>PopulationIt first, PopulationIt last, SampleIt out, Distance n,
                    UniformRndBitGen<span class="sy3">&amp;&amp;</span> g<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="co1">// 混洗（shuffle）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> UniformRndBitGen<span class="sy1">&gt;</span>
    <span class="kw4">void</span> shuffle<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, UniformRndBitGen<span class="sy3">&amp;&amp;</span> g<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Gen<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               UniformRandomBitGenerator<span class="sy1">&lt;</span>remove_reference_t<span class="sy1">&lt;</span>Gen<span class="sy1">&gt;&gt;</span> <span class="sy3">&amp;&amp;</span>
               ConvertibleTo<span class="sy1">&lt;</span>invoke_result_t<span class="sy1">&lt;</span>Gen<span class="sy3">&amp;</span><span class="sy1">&gt;</span>, iter_difference_t<span class="sy1">&lt;</span>I<span class="sy1">&gt;&gt;</span>
      I shuffle<span class="br0">(</span>I first, S last, Gen<span class="sy3">&amp;&amp;</span> g<span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Gen<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span> <span class="sy3">&amp;&amp;</span>
               UniformRandomBitGenerator<span class="sy1">&lt;</span>remove_reference_t<span class="sy1">&lt;</span>Gen<span class="sy1">&gt;&gt;</span> <span class="sy3">&amp;&amp;</span>
               ConvertibleTo<span class="sy1">&lt;</span>invoke_result_t<span class="sy1">&lt;</span>Gen<span class="sy3">&amp;</span><span class="sy1">&gt;</span>, iter_difference_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;&gt;</span>
      safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> shuffle<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Gen<span class="sy3">&amp;&amp;</span> g<span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 移位（shift）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      shift_left<span class="br0">(</span>ForwardIt first, ForwardIt last,
                 <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>ForwardIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span> n<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      shift_left<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                 ForwardIt first, ForwardIt last,
                 <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>ForwardIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span> n<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      shift_right<span class="br0">(</span>ForwardIt first, ForwardIt last,
                  <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>ForwardIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span> n<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      shift_right<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt first, ForwardIt last,
                  <span class="kw1">typename</span> iterator_traits<span class="sy1">&lt;</span>ForwardIt<span class="sy1">&gt;</span><span class="sy4">::</span><span class="me2">difference_type</span> n<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="co1">// 排序与相关操作：</span>
  <span class="co1">// 排序：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> sort<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> sort<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> sort<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
              RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">void</span> sort<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
              RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        sort<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        sort<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> stable_sort<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">void</span> stable_sort<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> stable_sort<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">void</span> stable_sort<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      I stable_sort<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        stable_sort<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> partial_sort<span class="br0">(</span>RandomAccessIt first, RandomAccessIt middle,
                                RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> partial_sort<span class="br0">(</span>RandomAccessIt first, RandomAccessIt middle,
                                RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> partial_sort<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                      RandomAccessIt first, RandomAccessIt middle, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">void</span> partial_sort<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                      RandomAccessIt first, RandomAccessIt middle, RandomAccessIt last,
                      Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        partial_sort<span class="br0">(</span>I first, I middle, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        partial_sort<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> middle, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                     Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> RandomAccessIt
      partial_sort_copy<span class="br0">(</span>InputIt first, InputIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> RandomAccessIt
      partial_sort_copy<span class="br0">(</span>InputIt first, InputIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last,
                        Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    RandomAccessIt
      partial_sort_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec, 
                        ForwardIt first, ForwardIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    RandomAccessIt
      partial_sort_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec, 
                        ForwardIt first, ForwardIt last,
                        RandomAccessIt result_first, RandomAccessIt result_last,
                        Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, RandomAccessIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I1, I2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> Sortable<span class="sy1">&lt;</span>I2, Comp, Proj2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectStrictWeakOrder<span class="sy1">&lt;</span>Comp, projected<span class="sy1">&lt;</span>I1, Proj1<span class="sy1">&gt;</span>, projected<span class="sy1">&lt;</span>I2, Proj2<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> I2
        partial_sort_copy<span class="br0">(</span>I1 first, S1 last, I2 result_first, S2 result_last,
                          Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, RandomAccessRange R2, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;&gt;</span> <span class="sy3">&amp;&amp;</span>
               Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Comp, Proj2<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectStrictWeakOrder<span class="sy1">&lt;</span>Comp, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, Proj1<span class="sy1">&gt;</span>,
                                       projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Proj2<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>
        partial_sort_copy<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r, R2<span class="sy3">&amp;&amp;</span> result_r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                          Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_sorted<span class="br0">(</span>ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_sorted<span class="br0">(</span>ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> is_sorted<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                   ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> is_sorted<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                   ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_sorted<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_sorted<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      is_sorted_until<span class="br0">(</span>ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      is_sorted_until<span class="br0">(</span>ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      is_sorted_until<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                      ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt
      is_sorted_until<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                      ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I is_sorted_until<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        is_sorted_until<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 第 N 元素：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> nth_element<span class="br0">(</span>RandomAccessIt first, RandomAccessIt nth,
                               RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> nth_element<span class="br0">(</span>RandomAccessIt first, RandomAccessIt nth,
                               RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> nth_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     RandomAccessIt first, RandomAccessIt nth,
                     RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">void</span> nth_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     RandomAccessIt first, RandomAccessIt nth,
                     RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        nth_element<span class="br0">(</span>I first, I nth, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        nth_element<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> nth, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 二分搜索：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      lower_bound<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      lower_bound<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I lower_bound<span class="br0">(</span>I first, S last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                              Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span>
               ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        lower_bound<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      upper_bound<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      upper_bound<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I upper_bound<span class="br0">(</span>I first, S last,
                              <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span>
               ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        upper_bound<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>ForwardIt, ForwardIt<span class="sy1">&gt;</span>
      equal_range<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>ForwardIt, ForwardIt<span class="sy1">&gt;</span>
      equal_range<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> subrange<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>
        equal_range<span class="br0">(</span>I first, S last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span>
               ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_subrange_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        equal_range<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span>
      binary_search<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span>
      binary_search<span class="br0">(</span>ForwardIt first, ForwardIt last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> binary_search<span class="br0">(</span>I first, S last, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                   Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span>
               ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> binary_search<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, <span class="kw4">const</span> T<span class="sy3">&amp;</span> value, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                   Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 划分（partition）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_partitioned<span class="br0">(</span>InputIt first, InputIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> is_partitioned<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                        ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_partitioned<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_partitioned<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt partition<span class="br0">(</span>ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    ForwardIt partition<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                        ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Permutable I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        partition<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        partition<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    BidirectionalIt stable_partition<span class="br0">(</span>BidirectionalIt first, BidirectionalIt last,
                                     Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    BidirectionalIt stable_partition<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                                     BidirectionalIt first, BidirectionalIt last,
                                     Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>
      I stable_partition<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires Permutable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
      safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> stable_partition<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt, <span class="kw1">class</span> OutputIt1, <span class="kw1">class</span> OutputIt2, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>OutputIt1, OutputIt2<span class="sy1">&gt;</span>
      partition_copy<span class="br0">(</span>InputIt first, InputIt last, OutputIt1 out_true, OutputIt2 out_false,
                     Pred pred<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> ForwardIt1,
           <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    pair<span class="sy1">&lt;</span>ForwardIt1, ForwardIt2<span class="sy1">&gt;</span>
      partition_copy<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, ForwardIt last,
                     ForwardIt1 out_true, ForwardIt2 out_false,
                     Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O1, <span class="kw1">class</span> O2<span class="sy1">&gt;</span>
    <span class="kw1">struct</span> partition_copy_result <span class="br0">{</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> I  in<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> O1 out1<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> O2 out2<span class="sy4">;</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> II, <span class="kw1">class</span> OO1, <span class="kw1">class</span> OO2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> I<span class="sy3">&amp;</span>, II<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
          ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> O1<span class="sy3">&amp;</span>, OO1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> O2<span class="sy3">&amp;</span>, OO2<span class="sy1">&gt;</span>
        operator partition_copy_result<span class="sy1">&lt;</span>II, OO1, OO2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="sy3">&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>in, out1, out2<span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> II, <span class="kw1">class</span> OO1, <span class="kw1">class</span> OO2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span>I, II<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
          ConvertibleTo<span class="sy1">&lt;</span>O1, OO1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> ConvertibleTo<span class="sy1">&lt;</span>O2, OO2<span class="sy1">&gt;</span>
        operator partition_copy_result<span class="sy1">&lt;</span>II, OO1, OO2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>in<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>out1<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>out2<span class="br0">)</span><span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S,
             WeaklyIncrementable O1, WeaklyIncrementable O2,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity, IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>I, O1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span> IndirectlyCopyable<span class="sy1">&lt;</span>I, O2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> partition_copy_result<span class="sy1">&lt;</span>I, O1, O2<span class="sy1">&gt;</span>
        partition_copy<span class="br0">(</span>I first, S last, O1 out_true, O2 out_false, Pred pred,
                       Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, WeaklyIncrementable O1, WeaklyIncrementable O2,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      requires IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O1<span class="sy1">&gt;</span> <span class="sy3">&amp;&amp;</span>
               IndirectlyCopyable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> partition_copy_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, O1, O2<span class="sy1">&gt;</span>
        partition_copy<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, O1 out_true, O2 out_false, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Pred<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt
      partition_point<span class="br0">(</span>ForwardIt first, ForwardIt last, Pred pred<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I partition_point<span class="br0">(</span>I first, S last, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectUnaryPredicate<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Pred<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        partition_point<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Pred pred, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 归并（merge）：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      merge<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
            OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      merge<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
            OutputIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      merge<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
            ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
            ForwardIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt
      merge<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
            ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
            ForwardIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> merge_result <span class="sy1">=</span> binary_transform_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             WeaklyIncrementable O, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity,
             <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>I1, I2, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> merge_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span>
        merge<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, O result,
              Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, WeaklyIncrementable O,
             <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> merge_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        merge<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, O result,
              Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> inplace_merge<span class="br0">(</span>BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">void</span> inplace_merge<span class="br0">(</span>BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> BidirectionalIt<span class="sy1">&gt;</span>
    <span class="kw4">void</span> inplace_merge<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                       BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">void</span> inplace_merge<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                       BidirectionalIt first,
                       BidirectionalIt middle,
                       BidirectionalIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      I inplace_merge<span class="br0">(</span>I first, I middle, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        inplace_merge<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span> middle, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                      Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 集合（set）操作：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> includes<span class="br0">(</span>InputIt1 first1, InputIt1 last1,
                            InputIt2 first2, InputIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> includes<span class="br0">(</span>InputIt1 first1, InputIt1 last1,
                            InputIt2 first2, InputIt2 last2,
                            Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> includes<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> includes<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                  ForwardIt1 first1, ForwardIt1 last1,
                  ForwardIt2 first2, ForwardIt2 last2,
                  Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I1, Proj1<span class="sy1">&gt;</span>, projected<span class="sy1">&lt;</span>I2, Proj2<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span>
               ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> includes<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                              Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity,
             <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, Proj1<span class="sy1">&gt;</span>,
                                     projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Proj2<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> includes<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                              Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      set_union<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
                set_union<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                OutputIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      set_union<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
                ForwardIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt
      set_union<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                ForwardIt1 first1, ForwardIt1 last1, ForwardIt2 first2, ForwardIt2 last2,
                ForwardIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> set_union_result <span class="sy1">=</span> binary_transform_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             WeaklyIncrementable O, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>I1, I2, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> set_union_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span>
        set_union<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, O result, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                  Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, WeaklyIncrementable O,
             <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> set_union_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        set_union<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, O result, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                  Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      set_intersection<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                       OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      set_intersection<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                       OutputIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      set_intersection<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                       ForwardIt1 first1, ForwardIt1 last1,
                       ForwardIt2 first2, ForwardIt2 last2,
                       ForwardIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt
      set_intersection<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                       ForwardIt1 first1, ForwardIt1 last1,
                       ForwardIt2 first2, ForwardIt2 last2,
                       ForwardIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> set_intersection_result <span class="sy1">=</span> binary_transform_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             WeaklyIncrementable O, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>I1, I2, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> set_intersection_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span>
        set_intersection<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, O result,
                         Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, WeaklyIncrementable O,
             <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> set_intersection_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        set_intersection<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, O result,
                         Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      set_difference<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                     OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      set_difference<span class="br0">(</span>InputIt1 first1, InputIt1 last1, InputIt2 first2, InputIt2 last2,
                     OutputIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      set_difference<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2, ForwardIt2 last2,
                     ForwardIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt
      set_difference<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt1 first1, ForwardIt1 last1,
                     ForwardIt2 first2, ForwardIt2 last2,
                     ForwardIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> set_difference_result <span class="sy1">=</span> copy_result<span class="sy1">&lt;</span>I, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             WeaklyIncrementable O, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>I1, I2, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> set_difference_result<span class="sy1">&lt;</span>I1, O<span class="sy1">&gt;</span>
        set_difference<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, O result,
                       Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, WeaklyIncrementable O,
             <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> set_difference_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        set_difference<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, O result,
                       Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      set_symmetric_difference<span class="br0">(</span>InputIt1 first1, InputIt1 last1,
                               InputIt2 first2, InputIt2 last2,
                               OutputIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> OutputIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> OutputIt
      set_symmetric_difference<span class="br0">(</span>InputIt1 first1, InputIt1 last1,
                               InputIt2 first2, InputIt2 last2,
                               OutputIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt
      set_symmetric_difference<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                               ForwardIt1 first1, ForwardIt1 last1,
                               ForwardIt2 first2, ForwardIt2 last2,
                               ForwardIt result<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt
      set_symmetric_difference<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                               ForwardIt1 first1, ForwardIt1 last1,
                               ForwardIt2 first2, ForwardIt2 last2,
                               ForwardIt result, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I1, <span class="kw1">class</span> I2, <span class="kw1">class</span> O<span class="sy1">&gt;</span>
    <span class="kw1">using</span> set_symmetric_difference_result <span class="sy1">=</span> binary_transform_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             WeaklyIncrementable O, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>I1, I2, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> set_symmetric_difference_result<span class="sy1">&lt;</span>I1, I2, O<span class="sy1">&gt;</span>
        set_symmetric_difference<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2, O result,
                                 Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                 Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, WeaklyIncrementable O,
             <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Mergeable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O, Comp, Proj1, Proj2<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span>
        set_symmetric_difference_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, safe_iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, O<span class="sy1">&gt;</span>
        set_symmetric_difference<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, O result, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                 Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 堆（heap）操作：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> push_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> push_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        push_heap<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        push_heap<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> pop_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> pop_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        pop_heap<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        pop_heap<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> make_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> make_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        make_heap<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        make_heap<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> sort_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">void</span> sort_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I
        sort_heap<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        sort_heap<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_heap<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> is_heap<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                 RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">bool</span> is_heap<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                 RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_heap<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span> is_heap<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> RandomAccessIt
      is_heap_until<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> RandomAccessIt
      is_heap_until<span class="br0">(</span>RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt<span class="sy1">&gt;</span>
    RandomAccessIt
      is_heap_until<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    RandomAccessIt first, RandomAccessIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> RandomAccessIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    RandomAccessIt
      is_heap_until<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                    RandomAccessIt first, RandomAccessIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I is_heap_until<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>RandomAccessRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        is_heap_until<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 最小与最大：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> min<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> min<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> T min<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> t<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> T min<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> t, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> min<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Copyable T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> T min<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      requires IndirectlyCopyableStorable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, iter_value_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span><span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> iter_value_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
        min<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> max<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> max<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> T max<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> t<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> T max<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> t, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> max<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Copyable T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> T max<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      requires IndirectlyCopyableStorable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, iter_value_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span><span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> iter_value_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
        max<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span> <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span>, <span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span> minmax<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span>, <span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span> minmax<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>T, T<span class="sy1">&gt;</span> minmax<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> t<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>T, T<span class="sy1">&gt;</span> minmax<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> t, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw1">struct</span> minmax_result <span class="br0">{</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> T min<span class="sy4">;</span>
      <span class="br0">[</span><span class="br0">[</span>no_unique_address<span class="br0">]</span><span class="br0">]</span> T max<span class="sy4">;</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span>, T2<span class="sy1">&gt;</span>
        operator minmax_result<span class="sy1">&lt;</span>T2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="kw4">const</span> <span class="sy3">&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>min, max<span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
 
      <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T2<span class="sy1">&gt;</span>
        requires ConvertibleTo<span class="sy1">&lt;</span>T, T2<span class="sy1">&gt;</span>
        operator minmax_result<span class="sy1">&lt;</span>T2<span class="sy1">&gt;</span><span class="br0">(</span><span class="br0">)</span> <span class="sy3">&amp;&amp;</span> <span class="br0">{</span>
          <span class="kw1">return</span> <span class="br0">{</span>std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>min<span class="br0">)</span>, std<span class="sy4">::</span><span class="me2">move</span><span class="br0">(</span>max<span class="br0">)</span><span class="br0">}</span><span class="sy4">;</span>
        <span class="br0">}</span>
    <span class="br0">}</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> minmax_result<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy3">&amp;</span><span class="sy1">&gt;</span>
        minmax<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> T<span class="sy3">&amp;</span> b, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>Copyable T, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span><span class="kw4">const</span> T<span class="sy2">*</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> minmax_result<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span>
        minmax<span class="br0">(</span>initializer_list<span class="sy1">&lt;</span>T<span class="sy1">&gt;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      requires IndirectlyCopyableStorable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, iter_value_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span><span class="sy2">*</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> minmax_result<span class="sy1">&lt;</span>iter_value_t<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;&gt;</span>
        minmax<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt min_element<span class="br0">(</span>ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt min_element<span class="br0">(</span>ForwardIt first, ForwardIt last,
                                          Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt min_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                          ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt min_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                          ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I min_element<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        min_element<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt max_element<span class="br0">(</span>ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> ForwardIt max_element<span class="br0">(</span>ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    ForwardIt max_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                          ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    ForwardIt max_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                          ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
 <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> I max_element<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>
        max_element<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>ForwardIt, ForwardIt<span class="sy1">&gt;</span>
      minmax_element<span class="br0">(</span>ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> pair<span class="sy1">&lt;</span>ForwardIt, ForwardIt<span class="sy1">&gt;</span>
      minmax_element<span class="br0">(</span>ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt<span class="sy1">&gt;</span>
    pair<span class="sy1">&lt;</span>ForwardIt, ForwardIt<span class="sy1">&gt;</span>
      minmax_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, ForwardIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    pair<span class="sy1">&lt;</span>ForwardIt, ForwardIt<span class="sy1">&gt;</span>
      minmax_element<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                     ForwardIt first, ForwardIt last, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> I<span class="sy1">&gt;</span>
    <span class="kw1">using</span> minmax_element_result <span class="sy1">=</span> minmax_result<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span><span class="sy4">;</span>
 
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> minmax_element_result<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span>
        minmax_element<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>ForwardRange R, <span class="kw1">class</span> Proj <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Proj<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> minmax_element_result<span class="sy1">&lt;</span>safe_iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;&gt;</span>
        minmax_element<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 有界值：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> clamp<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> v, <span class="kw4">const</span> T<span class="sy3">&amp;</span> lo, <span class="kw4">const</span> T<span class="sy3">&amp;</span> hi<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">const</span> T<span class="sy3">&amp;</span> clamp<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> v, <span class="kw4">const</span> T<span class="sy3">&amp;</span> lo, <span class="kw4">const</span> T<span class="sy3">&amp;</span> hi, Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="co1">// 字典序比较：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span>
      lexicographical_compare<span class="br0">(</span>InputIt1 first1, InputIt1 last1,
                              InputIt2 first2, InputIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span>
      lexicographical_compare<span class="br0">(</span>InputIt1 first1, InputIt1 last1,
                              InputIt2 first2, InputIt2 last2,
                              Compare comp<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2<span class="sy1">&gt;</span>
    <span class="kw4">bool</span>
      lexicographical_compare<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                              ForwardIt1 first1, ForwardIt1 last1,
                              ForwardIt2 first2, ForwardIt2 last2<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> ExecutionPolicy, <span class="kw1">class</span> ForwardIt1, <span class="kw1">class</span> ForwardIt2,
           <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">bool</span>
      lexicographical_compare<span class="br0">(</span>ExecutionPolicy<span class="sy3">&amp;&amp;</span> exec,
                              ForwardIt1 first1, ForwardIt1 last1,
                              ForwardIt2 first2, ForwardIt2 last2,
                              Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputIterator I1, Sentinel<span class="sy1">&lt;</span>I1<span class="sy1">&gt;</span> S1, InputIterator I2, Sentinel<span class="sy1">&lt;</span>I2<span class="sy1">&gt;</span> S2,
             <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity, <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>I1, Proj1<span class="sy1">&gt;</span>, projected<span class="sy1">&lt;</span>I2, Proj2<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span>
               ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span>
        lexicographical_compare<span class="br0">(</span>I1 first1, S1 last1, I2 first2, S2 last2,
                                Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>InputRange R1, InputRange R2, <span class="kw1">class</span> Proj1 <span class="sy1">=</span> identity,
             <span class="kw1">class</span> Proj2 <span class="sy1">=</span> identity,
             IndirectStrictWeakOrder<span class="sy1">&lt;</span>projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R1<span class="sy1">&gt;</span>, Proj1<span class="sy1">&gt;</span>,
                                     projected<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R2<span class="sy1">&gt;</span>, Proj2<span class="sy1">&gt;&gt;</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span><span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span>
        lexicographical_compare<span class="br0">(</span>R1<span class="sy3">&amp;&amp;</span> r1, R2<span class="sy3">&amp;&amp;</span> r2, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>,
                                Proj1 proj1 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj2 proj2 <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="co1">// 三路比较算法：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> T, <span class="kw1">class</span> U<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">auto</span> compare_3way<span class="br0">(</span><span class="kw4">const</span> T<span class="sy3">&amp;</span> a, <span class="kw4">const</span> U<span class="sy3">&amp;</span> b<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2, <span class="kw1">class</span> Cmp<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">auto</span>
      lexicographical_compare_3way<span class="br0">(</span>InputIt1 b1, InputIt1 e1, InputIt2 b2, InputIt2 e2,
                                   Cmp comp<span class="br0">)</span>
        <span class="sy2">-</span><span class="sy1">&gt;</span> common_comparison_category_t<span class="sy1">&lt;</span>decltype<span class="br0">(</span>comp<span class="br0">(</span><span class="sy2">*</span>b1, <span class="sy2">*</span>b2<span class="br0">)</span><span class="br0">)</span>, strong_ordering<span class="sy1">&gt;</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> InputIt1, <span class="kw1">class</span> InputIt2<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">auto</span>
      lexicographical_compare_3way<span class="br0">(</span>InputIt1 b1, InputIt1 e1, InputIt2 b2, InputIt2 e2<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="co1">// 排列：</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> next_permutation<span class="br0">(</span>BidirectionalIt first, BidirectionalIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> next_permutation<span class="br0">(</span>BidirectionalIt first, BidirectionalIt last,
                                    Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span>
        next_permutation<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span>
        next_permutation<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
 
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> prev_permutation<span class="br0">(</span>BidirectionalIt first, BidirectionalIt last<span class="br0">)</span><span class="sy4">;</span>
  <span class="kw1">template</span><span class="sy1">&lt;</span><span class="kw1">class</span> BidirectionalIt, <span class="kw1">class</span> Compare<span class="sy1">&gt;</span>
    <span class="kw4">constexpr</span> <span class="kw4">bool</span> prev_permutation<span class="br0">(</span>BidirectionalIt first, BidirectionalIt last,
                                    Compare comp<span class="br0">)</span><span class="sy4">;</span>
 
  <span class="kw1">namespace</span> ranges <span class="br0">{</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalIterator I, Sentinel<span class="sy1">&lt;</span>I<span class="sy1">&gt;</span> S, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>I, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span>
        prev_permutation<span class="br0">(</span>I first, S last, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">template</span><span class="sy1">&lt;</span>BidirectionalRange R, <span class="kw1">class</span> Comp <span class="sy1">=</span> ranges<span class="sy4">::</span><span class="me2">less</span>,
             <span class="kw1">class</span> Proj <span class="sy1">=</span> identity<span class="sy1">&gt;</span>
      requires Sortable<span class="sy1">&lt;</span>iterator_t<span class="sy1">&lt;</span>R<span class="sy1">&gt;</span>, Comp, Proj<span class="sy1">&gt;</span>
      <span class="kw4">constexpr</span> <span class="kw4">bool</span>
        prev_permutation<span class="br0">(</span>R<span class="sy3">&amp;&amp;</span> r, Comp comp <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span>, Proj proj <span class="sy1">=</span> <span class="br0">{</span><span class="br0">}</span><span class="br0">)</span><span class="sy4">;</span>
  <span class="br0">}</span>
<span class="br0">}</span></pre></div></div>

<!-- 
NewPP limit report
Preprocessor visited node count: 21892/1000000
Preprocessor generated node count: 13386/1000000
Post‐expand include size: 760212/2097152 bytes
Template argument size: 229245/2097152 bytes
Highest expansion depth: 20/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_zh_:pcache:idhash:10120-0!*!0!!zh!*!zh!* and timestamp 20190823150928 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    来自“<a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/header/algorithm&amp;oldid=60803">https://zh.cppreference.com/mwiki/index.php?title=cpp/header/algorithm&amp;oldid=60803</a>”                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>导航</h5>
            <ul><li><a href="https://zh.cppreference.com/w/cpp/header/algorithm">Online version</a></li><li>Offline version retrieved 2019-08-25 10:54.</li></ul></div>
                        <ul id="footer-info">
                                    <li id="footer-info-lastmod"> 本页面最后修改于2019年5月29日 (星期三) 02:05。</li>
                                    <li id="footer-info-viewcount">此页面已被浏览过9,233次。</li>
                            </ul>
                    </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.MathJax","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 4.964 secs. -->
	</body>
<!-- Cached 20190823150928 -->
</html>