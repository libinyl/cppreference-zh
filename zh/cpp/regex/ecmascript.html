<!DOCTYPE html>
<html lang="zh" dir="ltr" class="client-nojs">
<head>
<title>改 ECMAScript 正则表达式文法</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../../../common/favicon.ico">
<link rel="stylesheet" href="../../../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../../../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-css:7:15cea3ec788a65b5187d4018eed543bf */</style>

<script src="../../../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"cpp/regex/ecmascript","wgTitle":"cpp/regex/ecmascript","wgCurRevisionId":56864,"wgArticleId":10252,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Todo no example"],"wgBreakFrames":false,"wgPageContentLanguage":"zh","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"zh","wgMonthNames":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgMonthNamesShort":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgRelevantPageName":"cpp/regex/ecmascript","wgUserVariant":"zh","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"zh","language":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-MathJax":1,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-js:7:258d7cd6aa9aa67dee25e01fb6a9e505 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-cpp {line-height: normal;}
.source-cpp li, .source-cpp pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for cpp
 * CSS class: source-cpp, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.cpp.source-cpp .de1, .cpp.source-cpp .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.cpp.source-cpp  {font-family:monospace;}
.cpp.source-cpp .imp {font-weight: bold; color: red;}
.cpp.source-cpp li, .cpp.source-cpp .li1 {font-weight: normal; vertical-align:top;}
.cpp.source-cpp .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.cpp.source-cpp .li2 {font-weight: bold; vertical-align:top;}
.cpp.source-cpp .kw1 {color: #0000dd;}
.cpp.source-cpp .kw2 {color: #0000ff;}
.cpp.source-cpp .kw3 {color: #0000dd;}
.cpp.source-cpp .kw4 {color: #0000ff;}
.cpp.source-cpp .co1 {color: #909090;}
.cpp.source-cpp .co2 {color: #339900;}
.cpp.source-cpp .coMULTI {color: #ff0000; font-style: italic;}
.cpp.source-cpp .es0 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es1 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es2 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es3 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es4 {color: #008000; font-weight: bold;}
.cpp.source-cpp .es5 {color: #008000; font-weight: bold;}
.cpp.source-cpp .br0 {color: #008000;}
.cpp.source-cpp .sy0 {color: #008000;}
.cpp.source-cpp .sy1 {color: #000080;}
.cpp.source-cpp .sy2 {color: #000040;}
.cpp.source-cpp .sy3 {color: #000040;}
.cpp.source-cpp .sy4 {color: #008080;}
.cpp.source-cpp .st0 {color: #008000;}
.cpp.source-cpp .nu0 {color: #000080;}
.cpp.source-cpp .nu6 {color: #000080;}
.cpp.source-cpp .nu8 {color: #000080;}
.cpp.source-cpp .nu12 {color: #000080;}
.cpp.source-cpp .nu16 {color:#000080;}
.cpp.source-cpp .nu17 {color:#000080;}
.cpp.source-cpp .nu18 {color:#000080;}
.cpp.source-cpp .nu19 {color:#000080;}
.cpp.source-cpp .ln-xtra, .cpp.source-cpp li.ln-xtra, .cpp.source-cpp div.ln-xtra {background-color: #ffc;}
.cpp.source-cpp span.xtra { display:block; }

/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-cpp_regex_ecmascript skin-cppreference2 action-view cpp-navbar">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
<div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<h1 id="firstHeading" class="firstHeading">改 ECMAScript 正则表达式文法</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">来自cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"><span class="subpages">&lt; <a href="../../cpp.html" title="cpp">cpp</a>‎ | <a href="../regex.html" title="cpp/regex">regex</a></span></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="zh" dir="ltr" class="mw-content-ltr"><div class="t-navbar" style=""><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../../cpp.html" title="cpp"> C++</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="line-height:1.1em;">
<tr class="t-nv"><td colspan="5"> <a href="../language.html" title="cpp/language">语言</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../header.html" title="cpp/header">标准库头文件</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../freestanding.html" title="cpp/freestanding"> 自立与有宿主实现</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../named_req.html" title="cpp/named req">具名要求</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html#.E8.AF.AD.E8.A8.80.E6.94.AF.E6.8C.81" title="cpp/utility">语言支持库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../concepts.html" title="cpp/concepts">概念库</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../error.html" title="cpp/error">诊断库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../utility.html" title="cpp/utility">工具库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../string.html" title="cpp/string">字符串库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../container.html" title="cpp/container">容器库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../iterator.html" title="cpp/iterator">迭代器库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../ranges.html" title="cpp/ranges"> 范围库</a> <span class="t-mark-rev t-since-cxx20">(C++20)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../algorithm.html" title="cpp/algorithm">算法库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../numeric.html" title="cpp/numeric">数值库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../io.html" title="cpp/io">输入/输出库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../locale.html" title="cpp/locale">本地化库</a> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../regex.html" title="cpp/regex">正则表达式库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../atomic.html" title="cpp/atomic">原子操作库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../thread.html" title="cpp/thread">线程支持库</a> <span class="t-mark-rev t-since-cxx11">(C++11)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../filesystem.html" title="cpp/filesystem">文件系统库</a> <span class="t-mark-rev t-since-cxx17">(C++17)</span> </td></tr>
<tr class="t-nv"><td colspan="5"> <a href="../experimental.html" title="cpp/experimental">技术规范</a> </td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="../regex.html" title="cpp/regex">正则表达式库</a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5"> 类</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex.html" title="cpp/regex/basic regex"><span class="t-lines"><span>basic_regex</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="sub_match.html" title="cpp/regex/sub match"><span class="t-lines"><span>sub_match</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="match_results.html" title="cpp/regex/match results"><span class="t-lines"><span>match_results</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> 算法</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="regex_match.html" title="cpp/regex/regex match"><span class="t-lines"><span>regex_match</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="regex_search.html" title="cpp/regex/regex search"><span class="t-lines"><span>regex_search</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="regex_replace.html" title="cpp/regex/regex replace"><span class="t-lines"><span>regex_replace</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> 迭代器</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="regex_iterator.html" title="cpp/regex/regex iterator"><span class="t-lines"><span>regex_iterator</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="regex_token_iterator.html" title="cpp/regex/regex token iterator"><span class="t-lines"><span>regex_token_iterator</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> 异常</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="regex_error.html" title="cpp/regex/regex error"><span class="t-lines"><span>regex_error</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> 特性</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="regex_traits.html" title="cpp/regex/regex traits"><span class="t-lines"><span>regex_traits</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> 常量</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="syntax_option_type.html" title="cpp/regex/syntax option type"><span class="t-lines"><span>syntax_option_type</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="match_flag_type.html" title="cpp/regex/match flag type"><span class="t-lines"><span>match_flag_type</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="error_type.html" title="cpp/regex/error type"><span class="t-lines"><span>error_type</span></span></a></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> 正则表达式文法</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><strong class="selflink"><span class="t-lines"><span>Modified ECMAScript-262</span></span></strong></div><div><span class="t-lines"><span><span class="t-mark-rev t-since-cxx11">(C++11)</span></span></span></div></div></td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div><div class="t-navbar-head"><a href="basic_regex.html" title="cpp/regex/basic regex"><tt>std::basic_regex</tt></a><div class="t-navbar-menu"><div><div><table class="t-nv-begin" cellpadding="0" style="">
<tr class="t-nv-h1"><td colspan="5"> 成员函数</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/basic_regex.html" title="cpp/regex/basic regex/basic regex"><span class="t-lines"><span>basic_regex::basic_regex</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/~basic_regex.html" title="cpp/regex/basic regex/~basic regex"><span class="t-lines"><span>basic_regex::~basic_regex</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/operator%3D.html" title="cpp/regex/basic regex/operator="><span class="t-lines"><span>basic_regex::operator=</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/assign.html" title="cpp/regex/basic regex/assign"><span class="t-lines"><span>basic_regex::assign</span></span></a></div></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 观察器</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/mark_count.html" title="cpp/regex/basic regex/mark count"><span class="t-lines"><span>basic_regex::mark_count</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/flags.html" title="cpp/regex/basic regex/flags"><span class="t-lines"><span>basic_regex::flags</span></span></a></div></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 本地环境</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/getloc.html" title="cpp/regex/basic regex/getloc"><span class="t-lines"><span>basic_regex::getloc</span></span></a></div></div></td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/imbue.html" title="cpp/regex/basic regex/imbue"><span class="t-lines"><span>basic_regex::imbue</span></span></a></div></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 修改器</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/swap.html" title="cpp/regex/basic regex/swap"><span class="t-lines"><span>basic_regex::swap</span></span></a></div></div></td></tr>
<tr class="t-nv-h2"><td colspan="5"> 常量</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/constants.html" title="cpp/regex/basic regex/constants"><span class="t-lines"><span>basic_regex 常量</span></span></a></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> 非成员函数</td></tr>
<tr class="t-nv"><td colspan="5"><div class="t-nv-ln-table"><div><a href="basic_regex/swap2.html" title="cpp/regex/basic regex/swap2"><span class="t-lines"><span>swap<span class="t-dsc-small">(std::basic_regex)</span></span></span></a></div></div></td></tr>
<tr class="t-nv-h1"><td colspan="5"> <a href="basic_regex/deduction_guides.html" title="cpp/regex/basic regex/deduction guides">推导指引</a><span class="t-mark-rev t-since-cxx17">(C++17)</span></td></tr>
</table></div><div></div></div></div></div><div class="t-navbar-sep"> </div></div>
<p>此页面描述以设置为 <code>ECMAScript</code> （默认值）的 <a href="syntax_option_type.html" title="cpp/regex/syntax option type"><tt>syntax_option_type</tt></a> 构造 <span class="t-lc"><a href="basic_regex.html" title="cpp/regex/basic regex">std::basic_regex</a></span> 时使用的文法。其他受支持正则表达式文法见 <a href="syntax_option_type.html" title="cpp/regex/syntax option type"><tt>syntax_option_type</tt></a> 。
</p><p>C++ 中的 <code>ECMAScript</code> 正则表达式文法是带标记有后述 <span class="t-mark">(仅 C++)</span> 的修改的 <a rel="nofollow" class="external text" href="http://ecma-international.org/ecma-262/5.1/#sec-15.10">ECMA-262 文法</a>。
</p>
<h3><span class="mw-headline" id=".E5.8F.AF.E9.80.89.E9.A1.B9">可选项</span></h3>
<p>正则表达式模式是一或多个以析取运算符 <code><b>|</b></code> 分隔的可选项<i>可选项 (Alternative)</i> 序列（换言之，析取运算符拥有最低优先级）
</p><p><i>Pattern</i> ::
</p>
<dl><dd><i>Disjunction</i>
</dd></dl>
<p><i>Disjunction</i> ::
</p>
<dl><dd><i>Alternative</i>
</dd><dd><i>Alternative</i> <code><b>|</b></code> <i>Disjunction</i>
</dd></dl>
<p>模式首先尝试跳过<i>析取 (Disjunction)</i> 并匹配（析取后的）后随剩余正则表达式的<i>可选项</i>。
</p><p>若它失败，则试图跳过左侧<i>可选项</i>并匹配右侧<i>析取</i>（后随剩余正则表达式）。
</p><p>若左侧<i>可选项</i>、右侧<i>析取</i>和剩余正则表达式都拥有选择点，则在尝试移动到左侧<i>可选项</i>中的下个选择前，尝试剩余表达式值中的所有选择。若穷尽了左侧<i>可选项</i>中的所有选择，则取代左侧<i>可选项</i>尝试右侧<i>析取</i>。
</p><p>跳过的<i>可选项</i>内的任何捕获括号产生空子匹配。
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">运行此代码</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;regex&gt;</span>
 
<span class="kw4">void</span> show_matches<span class="br0">(</span><span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> in, <span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> re<span class="br0">)</span>
<span class="br0">{</span>
    <a href="match_results.html"><span class="kw2010">std::<span class="me2">smatch</span></span></a> m<span class="sy4">;</span>
    <a href="regex_search.html"><span class="kw2013">std::<span class="me2">regex_search</span></span></a><span class="br0">(</span>in, m, <a href="basic_regex.html"><span class="kw2000">std::<span class="me2">regex</span></span></a><span class="br0">(</span>re<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">if</span><span class="br0">(</span>m.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: NO MATCH<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"prefix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">prefix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <span class="kw1">for</span><span class="br0">(</span><a href="../types/size_t.html"><span class="kw100">std::<span class="me2">size_t</span></span></a> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> m.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span>
            <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">" m["</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">"]=["</span> <span class="sy1">&lt;&lt;</span> m<span class="br0">[</span>n<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"suffix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">suffix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"]<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    show_matches<span class="br0">(</span><span class="st0">"abcdef"</span>, <span class="st0">"abc|def"</span><span class="br0">)</span><span class="sy4">;</span>
    show_matches<span class="br0">(</span><span class="st0">"abc"</span>, <span class="st0">"ab|abc"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 首先匹配左侧可选项</span>
 
    <span class="co1">// 针对后随剩余正则表达式 (c|bc) 左侧可选项 (a) 的匹配成功</span>
    <span class="co1">// 它生成 m[1]="a" 及 m[4]="bc" 。</span>
    <span class="co1">// 跳过的可选项 (ab) 和 (c) 将其子匹配 m[3] 和 m[5] 置为空。</span>
    show_matches<span class="br0">(</span><span class="st0">"abc"</span>, <span class="st0">"((a)|(ab))((c)|(bc))"</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>输出：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">input=[abcdef], regex=[abc|def]: prefix=[]  m[0]=[abc] suffix=[def]
input=[abc], regex=[ab|abc]: prefix=[]  m[0]=[ab] suffix=[c]
input=[abc], regex=[((a)|(ab))((c)|(bc))]: prefix=[]  m[0]=[abc]
m[1]=[a]  m[2]=[a]  m[3]=[] m[4]=[bc]  m[5]=[]  m[6]=[bc] suffix=[]</pre></div></div> 
</div>
<h3><span class="mw-headline" id=".E9.A1.B9">项</span></h3>
<p>每个<i>可选项</i>为空，或为<i>项 (Term)</i> 的序列（<i>项</i>间无分隔符）
</p><p><i>Alternative</i> ::
</p>
<dl><dd> <i>[empty]</i>
</dd><dd> <i>Alternative</i> <i>Term</i>
</dd></dl>
<p>空的<i>可选项</i>始终匹配并且不消耗任何输入。
</p><p>相继的<i>项</i>尝试同时匹配输入的连续部分。
</p><p>若左侧<i>可选项</i>、右侧<i>项</i>和剩余正则表达式拥有选择点，则在移动到右侧<i>项</i>中的下个选择前，尝试剩余正则表达式中的所有选择，并在移动到左侧<i>可选项</i>中的下个选择前，尝试右侧<i>项</i>中的所有选择。
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">运行此代码</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;regex&gt;</span>
 
<span class="kw4">void</span> show_matches<span class="br0">(</span><span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> in, <span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> re<span class="br0">)</span>
<span class="br0">{</span>
    <a href="match_results.html"><span class="kw2010">std::<span class="me2">smatch</span></span></a> m<span class="sy4">;</span>
    <a href="regex_search.html"><span class="kw2013">std::<span class="me2">regex_search</span></span></a><span class="br0">(</span>in, m, <a href="basic_regex.html"><span class="kw2000">std::<span class="me2">regex</span></span></a><span class="br0">(</span>re<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">if</span><span class="br0">(</span>m.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: NO MATCH<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"prefix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">prefix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <span class="kw1">for</span><span class="br0">(</span><a href="../types/size_t.html"><span class="kw100">std::<span class="me2">size_t</span></span></a> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> m.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span>
            <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">" m["</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">"]=["</span> <span class="sy1">&lt;&lt;</span> m<span class="br0">[</span>n<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"suffix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">suffix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"]<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    show_matches<span class="br0">(</span><span class="st0">"abcdef"</span>, <span class="st0">""</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 空正则表达式是单个空可选项</span>
    show_matches<span class="br0">(</span><span class="st0">"abc"</span>, <span class="st0">"abc|"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 左可选项首先匹配</span>
    show_matches<span class="br0">(</span><span class="st0">"abc"</span>, <span class="st0">"|abc"</span><span class="br0">)</span><span class="sy4">;</span> <span class="co1">// 左可选项首先匹配，留待 abc 未匹配</span>
<span class="br0">}</span></pre></div></div>
<p>输出：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">input=[abcdef], regex=[]: prefix=[]  m[0]=[] suffix=[abcdef]
input=[abc], regex=[abc|]: prefix=[]  m[0]=[abc] suffix=[]
input=[abc], regex=[|abc]: prefix=[]  m[0]=[] suffix=[abc]</pre></div></div> 
</div>
<h3><span class="mw-headline" id=".E6.95.B0.E9.87.8F.E8.AF.8D">数量词</span></h3>
<ul><li> 每个<i>项</i> 为<i>断言 (Assertion)</i>（见后方）或<i>原子 (Atom)</i> （见后方），或<i>原子</i>立即后随<i>数量词 (Quantifier)</i> 之一
</li></ul>
<p><i>Term</i> ::
</p>
<dl><dd> <i>Assertion</i>
</dd><dd> <i>Atom</i>
</dd><dd> <i>Atom</i> <i>Quantifier</i>
</dd></dl>
<p>每个<i>数量词</i>为<i>贪心 (greedy) </i>数量词（仅由一个<i>数量词前缀 (QuantifierPrefix)</i> 组成）或<i>非贪心 (non-greedy)</i> 数量词（由一个<i>数量词前缀</i>后随问号掩码 <code><b>?</b></code> 组成）。
</p><p><i>Quantifier</i> ::
</p>
<dl><dd> <i>QuantifierPrefix</i>
</dd><dd> <i>QuantifierPrefix</i> <code><b>?</b></code>
</dd></dl>
<p>每个<i>数量词前缀</i>确定二个数：最小重复数和最大重复数，如下：
</p>
<table class="wikitable">

<tr>
<th>数量词前缀</th>
<th>最小</th>
<th>最大
</th></tr>
<tr>
<td> <code><b>*</b></code>
</td>
<td> 零
</td>
<td> 无穷大
</td></tr>
<tr>
<td> <code><b>+</b></code>
</td>
<td> 一
</td>
<td> 无穷大
</td></tr>
<tr>
<td> <code><b>?</b></code>
</td>
<td> 零
</td>
<td> 一
</td></tr>
<tr>
<td> <code><b>{ </b></code> <i>十进制数</i> <code><b>} </b></code>
</td>
<td> 十进制数的值
</td>
<td> 十进制数的值
</td></tr>
<tr>
<td> <code><b>{</b></code> <i>十进制数</i> <code><b>,</b></code> <code><b>} </b></code>
</td>
<td> 十进制数的值
</td>
<td> 无穷大
</td></tr>
<tr>
<td> <code><b>{</b></code> <i>十进制数</i> <code><b>,</b></code> <i>十进制数</i> <code><b>} </b></code>
</td>
<td> 逗号前的十进制数的值
</td>
<td> 逗号后的十进制数的值
</td></tr></table>
<p>通过在每个数位上调用 <span class="t-lc"><a href="regex_traits/value.html" title="cpp/regex/regex traits/value">std::regex_traits::value</a></span><span class="t-mark">(仅 C++)</span>获得单独的<i>十进制数 (DecimalDigits)</i> 的值。
</p><p><i>原子</i>后随<i>数量词</i>重复<i>数量词</i>所指定的次数。<i>数量词</i>能为<i>非贪心</i>，该情况下<i>原子</i>模式重复在仍然匹配剩余正则表达式的同时尽可能少的次数，或能为<i>贪心</i>，该情况下<i>原子</i>模式重复在仍然匹配剩余正则表达式的同时金可鞥多的次数。
</p><p>重复的是<i>原子</i>模式，而非其所匹配的输入，故<i>原子</i>的不同重复能匹配不同的输入子串。
</p><p>若<i>原子</i>和剩余正则表达式都有选择点，则首先将<i>原子</i>匹配尽可能尽可能多（或少，若为<i>非贪心</i>）次。，移动到<i>原子</i>的最后一次重复中的下个选择前，尝试剩余正则表达式中的所有选择。移动到<i>原子</i>的倒数第二（第 n-1 ）次重复中的下个选择前，尝试<i>原子</i>的最后一（第 n ）次重复中的所有选择；在明确现在可能有<i>原子</i>的更多或更少重复时；在移动到<i>原子</i>的第 n-1 次重复中的下个选择前，将这些穷尽（再次以尽可能少或多开始），以此类推。
</p><p>每次重复<i>原子'</i>时，清除其捕获（见后方 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="st0">"(z)((a+)?(b+)?(c))*"</span></span></span> 的示例）
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">运行此代码</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;regex&gt;</span>
 
<span class="kw4">void</span> show_matches<span class="br0">(</span><span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> in, <span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> re<span class="br0">)</span>
<span class="br0">{</span>
    <a href="match_results.html"><span class="kw2010">std::<span class="me2">smatch</span></span></a> m<span class="sy4">;</span>
    <a href="regex_search.html"><span class="kw2013">std::<span class="me2">regex_search</span></span></a><span class="br0">(</span>in, m, <a href="basic_regex.html"><span class="kw2000">std::<span class="me2">regex</span></span></a><span class="br0">(</span>re<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">if</span><span class="br0">(</span>m.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: NO MATCH<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"prefix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">prefix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <span class="kw1">for</span><span class="br0">(</span><a href="../types/size_t.html"><span class="kw100">std::<span class="me2">size_t</span></span></a> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> m.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span>
            <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">" m["</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">"]=["</span> <span class="sy1">&lt;&lt;</span> m<span class="br0">[</span>n<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"suffix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">suffix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"]<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// 贪心匹配，重复 [a-z] 4 次</span>
    show_matches<span class="br0">(</span><span class="st0">"abcdefghi"</span>, <span class="st0">"a[a-z]{2,4}"</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="co1">// 非贪心匹配，重复 [a-z] 2 次</span>
    show_matches<span class="br0">(</span><span class="st0">"abcdefghi"</span>, <span class="st0">"a[a-z]{2,4}?"</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// 数量词的选择点顺序，生成带二个重复的匹配，</span>
    <span class="co1">// 第一个匹配子串 "aa" ，第二个匹配子串 "ba" ，保留 "ac" 匹配</span>
    <span class="co1">// （"ba" 出现于 m[1] 的捕获子句中）</span>
    show_matches<span class="br0">(</span><span class="st0">"aabaac"</span>, <span class="st0">"(aa|aabaac|ba|b|c)*"</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// 数量词的选择点顺序令此 regex 计算 10 与 15 间的最大公约数</span>
    <span class="co1">// （答案是 5 ，并以 "aaaaa" 填充 m[1] ）</span>
    show_matches<span class="br0">(</span><span class="st0">"aaaaaaaaaa,aaaaaaaaaaaaaaa"</span>, <span class="st0">"^(a+)<span class="es1">\\</span>1*,<span class="es1">\\</span>1+$"</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// 子串 "bbb" 不出现于捕获子句 m[4] 中</span>
    <span class="co1">// 因为它在原子 (a+)?(b+)?(c) 的第二次重复匹配子串 "ac" 时被声明</span>
    show_matches<span class="br0">(</span><span class="st0">"zaacbbbcac"</span>, <span class="st0">"(z)((a+)?(b+)?(c))*"</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>输出：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">input=[abcdefghi], regex=[a[a-z]{2,4}]: prefix=[]  m[0]=[abcde] suffix=[fghi]
input=[abcdefghi], regex=[a[a-z]{2,4}?]: prefix=[]  m[0]=[abc] suffix=[defghi]
input=[aabaac], regex=[(aa|aabaac|ba|b|c)*]:
 prefix=[]  m[0]=[aaba]  m[1]=[ba] suffix=[ac]
input=[aaaaaaaaaa,aaaaaaaaaaaaaaa], regex=[^(a+)\1*,\1+$]:
 prefix=[]  m[0]=[aaaaaaaaaa,aaaaaaaaaaaaaaa]  m[1]=[aaaaa] suffix=[]
input=[zaacbbbcac], regex=[(z)((a+)?(b+)?(c))*]:
prefix=[]  m[0]=[zaacbbbcac]  m[1]=[z]  m[2]=[ac]  m[3]=[a]  m[4]=[]  m[5]=[c] suffix=[]</pre></div></div> 
</div>
<h3><span class="mw-headline" id=".E6.96.AD.E8.A8.80">断言</span></h3>
<p><i>断言 (Assertion)</i> 匹配条件，而非输入字符串的子串。它们决不消耗任何来自输入的字符。每个<i>断言</i>是下列之一
</p><p><i>Assertion</i> ::
</p>
<dl><dd> <code><b>^</b></code>
</dd><dd> <code><b>$</b></code>
</dd><dd> <code><b>\</b></code> <code><b>b</b></code>
</dd><dd> <code><b>\</b></code> <code><b>B</b></code>
</dd><dd> <code><b>(</b></code> <code><b>?</b></code> <code><b>=</b></code> <i>Disjunction</i> <code><b>)</b></code>
</dd><dd> <code><b>(</b></code> <code><b>?</b></code> <code><b>!</b></code> <i>Disjunction</i> <code><b>)</b></code>
</dd></dl>
<p>断言 <code><b>^</b></code> （行起始）匹配
</p>
<div class="t-li1"><span class="t-li">1)</span> 立即后随<i>行终止符 (LineTerminator)</i> 字符的位置<span class="t-rev-inl t-until-cxx17"><span>（这可能不受支持）</span> <span><span class="t-mark-rev t-until-cxx17">(C++17 前)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>（这仅若启用 <a href="syntax_option_type.html" title="cpp/regex/syntax option type"><tt>std::regex_constants::multiline</tt></a><span class="t-mark">(仅 C++)</span> 才得到保证）</span> <span><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></span></span></div>
<div class="t-li1"><span class="t-li">2)</span> 输入的起始（除非启用 <span class="t-lc"><a href="match_flag_type.html" title="cpp/regex/match flag type">std::regex_constants::match_not_bol</a></span><span class="t-mark">(仅 C++)</span> ）</div>
<p>断言 <code><b>$</b></code> （行结尾）匹配
</p>
<div class="t-li1"><span class="t-li">1)</span> <i>行终止符</i>字符的位置<span class="t-rev-inl t-until-cxx17"><span>（这可能不受支持）</span> <span><span class="t-mark-rev t-until-cxx17">(C++17 前)</span></span></span><span class="t-rev-inl t-since-cxx17"><span>（这仅若启用 <a href="syntax_option_type.html" title="cpp/regex/syntax option type"><tt>std::regex_constants::multiline</tt></a><span class="t-mark">(仅 C++)</span> 才得到保证）</span> <span><span class="t-mark-rev t-since-cxx17">(C++17 起)</span></span></span></div>
<div class="t-li1"><span class="t-li">2)</span> 输入的结尾（除非启用 <span class="t-lc"><a href="match_flag_type.html" title="cpp/regex/match flag type">std::regex_constants::match_not_bol</a></span><span class="t-mark">(仅 C++)</span> ）</div>
<p>上面二个断言和下面的原子 <code><b>.</b></code> 中，<i>行终止符</i>是下列四个字符之一： <code>U+000A</code> （ <code>\n</code> 或换行）、 <code>U+000D</code> （ <code>\r</code> 或回车）、 <code>U+2028</code> （行分隔符）或 <code>U+2029</code> （段分隔符）
</p><p>断言 <code><b>\b</b></code> （词边界）匹配
</p>
<div class="t-li1"><span class="t-li">1)</span> 词的起始（当前字符为字母、数字或下划线，而前一字符不是）</div>
<div class="t-li1"><span class="t-li">2)</span> 词的结尾（当前字符不是字母、数字或下划线，而前一字符是这些之一）</div>
<div class="t-li1"><span class="t-li">3)</span> 输入的起始，若首字符为字母、数字或下划线（除非启用 <span class="t-lc"><a href="match_flag_type.html" title="cpp/regex/match flag type">std::regex_constants::match_not_bow</a></span><span class="t-mark">(仅 C++)</span> ）</div>
<div class="t-li1"><span class="t-li">4)</span> 输入的结尾，若末字符为字母、数字或下划线（除非启用 <span class="t-lc"><a href="match_flag_type.html" title="cpp/regex/match flag type">std::regex_constants::match_not_eow</a></span><span class="t-mark">(仅 C++)</span> ）</div>
<p>断言 <code><b>\B</b></code> （反词边界）匹配所有字符，<b>除了</b>下列内容
</p>
<div class="t-li1"><span class="t-li">1)</span> 词的起始（当前字符为字母、数字或下划线，而前一字符不是这些之一或不存在）</div>
<div class="t-li1"><span class="t-li">2)</span> 词的结尾（当前字符不是字母、数字或下划线（或匹配者在输入结尾），前一字符是这些之一）</div>
<p>若<i>析取</i>会匹配在当前位置的输入，则断言 <code><b>(</b></code> <code><b>?</b></code> <code><b>=</b></code> <i>析取</i> <code><b>)</b></code> （零宽正前瞻）匹配。
</p><p>若<i>析取</i><b>不</b>会匹配在当前位置的的输入，则断言 <code><b>(</b></code> <code><b>?</b></code> <code><b>!</b></code> <i>析取</i> <code><b>)</b></code> （零宽负前瞻）匹配。
</p><p>对于两个前瞻断言，在匹配<i>析取</i>时，不在匹配剩余正则表达式之前令位置前进。另外，若<i>析取</i>能以多种方式在当前位置匹配，则只尝试第一个。
</p><p>ECMAScript 禁止回撤到前瞻析取中，这影响到来自剩余正则表达式的正前瞻中的回溯引用（见下方示例） 。到来自剩余正则表达式的负前瞻中的回溯引用始终没有定义（因为前瞻断言必定无法继续）。
</p><p>注意：前瞻断言可用于创建多个正则表达式间的逻辑与（见下方示例）。
</p>
<div class="t-example"><div class="t-example-live-link"><div class="coliru-btn coliru-btn-run-init">运行此代码</div></div>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="cpp source-cpp"><pre class="de1"><span class="co2">#include &lt;iostream&gt;</span>
<span class="co2">#include &lt;regex&gt;</span>
 
<span class="kw4">void</span> show_matches<span class="br0">(</span><span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> in, <span class="kw4">const</span> <a href="../string/basic_string.html"><span class="kw1230">std::<span class="me2">string</span></span></a><span class="sy3">&amp;</span> re<span class="br0">)</span>
<span class="br0">{</span>
    <a href="match_results.html"><span class="kw2010">std::<span class="me2">smatch</span></span></a> m<span class="sy4">;</span>
    <a href="regex_search.html"><span class="kw2013">std::<span class="me2">regex_search</span></span></a><span class="br0">(</span>in, m, <a href="basic_regex.html"><span class="kw2000">std::<span class="me2">regex</span></span></a><span class="br0">(</span>re<span class="br0">)</span><span class="br0">)</span><span class="sy4">;</span>
    <span class="kw1">if</span><span class="br0">(</span>m.<span class="me1">empty</span><span class="br0">(</span><span class="br0">)</span><span class="br0">)</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: NO MATCH<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"input=["</span> <span class="sy1">&lt;&lt;</span> in <span class="sy1">&lt;&lt;</span> <span class="st0">"], regex=["</span> <span class="sy1">&lt;&lt;</span> re <span class="sy1">&lt;&lt;</span> <span class="st0">"]: "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"prefix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">prefix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <span class="kw1">for</span><span class="br0">(</span><a href="../types/size_t.html"><span class="kw100">std::<span class="me2">size_t</span></span></a> n <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span> n <span class="sy1">&lt;</span> m.<span class="me1">size</span><span class="br0">(</span><span class="br0">)</span><span class="sy4">;</span> <span class="sy2">++</span>n<span class="br0">)</span>
            <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">" m["</span> <span class="sy1">&lt;&lt;</span> n <span class="sy1">&lt;&lt;</span> <span class="st0">"]=["</span> <span class="sy1">&lt;&lt;</span> m<span class="br0">[</span>n<span class="br0">]</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"] "</span><span class="sy4">;</span>
        <a href="../io/cout.html"><span class="kw1758">std::<span class="me2">cout</span></span></a> <span class="sy1">&lt;&lt;</span> <span class="st0">"suffix=["</span> <span class="sy1">&lt;&lt;</span> m.<span class="me1">suffix</span><span class="br0">(</span><span class="br0">)</span> <span class="sy1">&lt;&lt;</span> <span class="st0">"]<span class="es1">\n</span>"</span><span class="sy4">;</span>
    <span class="br0">}</span>
<span class="br0">}</span>
<span class="kw4">int</span> main<span class="br0">(</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="co1">// 在输入结尾匹配 a</span>
    show_matches<span class="br0">(</span><span class="st0">"aaa"</span>, <span class="st0">"a$"</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// 在第一个词结尾匹配 o</span>
    show_matches<span class="br0">(</span><span class="st0">"moo goo gai pan"</span>, <span class="st0">"o<span class="es1">\\</span>b"</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// 前瞻匹配立即在第一个 b 之后的空字符串</span>
    <span class="co1">// 这以 "aaa" 填充 m[1] ，尽管 m[0] 为空</span>
    show_matches<span class="br0">(</span><span class="st0">"baaabac"</span>, <span class="st0">"(?=(a+))"</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// 因为禁止回溯引用回撤到前瞻中，</span>
    <span class="co1">// 这匹配 aba 而非 aaaba</span>
    show_matches<span class="br0">(</span><span class="st0">"baaabac"</span>, <span class="st0">"(?=(a+))a*b<span class="es1">\\</span>1"</span><span class="br0">)</span><span class="sy4">;</span>
 
    <span class="co1">// 经由前瞻的逻辑与：此密码匹配，若它含有</span>
    <span class="co1">// 至少一个小写字母</span>
    <span class="co1">// 与 至少一个大写字母</span>
    <span class="co1">// 与 至少一个标点字符</span>
    <span class="co1">// 与 至少有 6 个字符长</span>
    show_matches<span class="br0">(</span><span class="st0">"abcdef"</span>, <span class="st0">"(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}"</span><span class="br0">)</span><span class="sy4">;</span>
    show_matches<span class="br0">(</span><span class="st0">"aB,def"</span>, <span class="st0">"(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}"</span><span class="br0">)</span><span class="sy4">;</span>
<span class="br0">}</span></pre></div></div>
<p>输出：
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="text source-text"><pre class="de1">input=[aaa], regex=[a$]: prefix=[aa]  m[0]=[a] suffix=[]
input=[moo goo gai pan], regex=[o\b]: prefix=[mo]  m[0]=[o] suffix=[ goo gai pan]
input=[baaabac], regex=[(?=(a+))]: prefix=[b]  m[0]=[]  m[1]=[aaa] suffix=[aaabac]
input=[baaabac], regex=[(?=(a+))a*b\1]: prefix=[baa]  m[0]=[aba]  m[1]=[a] suffix=[c]
input=[abcdef], regex=[(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}]:
 NO MATCH
input=[aB,def], regex=[(?=.*[[:lower:]])(?=.*[[:upper:]])(?=.*[[:punct:]]).{6,}]:
 prefix=[]  m[0]=[aB,def] suffix=[]</pre></div></div> 
</div>
<h3><span class="mw-headline" id=".E5.8E.9F.E5.AD.90">原子</span></h3>
<p><i>原子</i>能为下列之一：
</p><p><i>Atom</i> ::
</p>
<dl><dd> <i>PatternCharacter</i>
</dd><dd> <code><b>.</b></code>
</dd><dd> <code><b>\</b></code> <i>AtomEscape</i>
</dd><dd> <i>CharacterClass</i>
</dd><dd> <code><b>(</b></code> <i>Disjunction</i> <code><b>)</b></code>
</dd><dd> <code><b>(</b></code> <code><b>?</b></code> <code><b>:</b></code> <i>Disjunction</i> <code><b>)</b></code>
</dd></dl>
<p>其中
<i>AtomEscape</i> ::
</p>
<dl><dd> <i>DecimalEscape</i>
</dd><dd> <i>CharacterEscape</i>
</dd><dd> <i>CharacterClassEscape</i>
</dd></dl>
<p>不同种类的原子求值方式不同。
</p>
<h3><span class="mw-headline" id=".E5.AD.90.E8.A1.A8.E8.BE.BE.E5.BC.8F">子表达式</span></h3>
<p><i>原子</i> <code><b>(</b></code> <i>析取</i> <code><b>)</b></code> 是有标记表达式：它执行<i>析取</i>并存储<i>析取</i>所消耗的输入子串于子匹配数组，下标对应在此点已遇到的整个正则表达式中，有标记子表达式的左开括号 <code><b>(</b></code> 次数。
</p><p>在返回于 <span class="t-lc"><a href="match_results.html" title="cpp/regex/match results">std::match_results</a></span> 之外，捕获的子匹配可作为回溯引用（ <code>\1</code> 、 <code>\2</code> ……）访问，而且能在 <span class="t-lc"><a href="regex_replace.html" title="cpp/regex/regex replace">std::regex_replace</a></span> 中引用。
</p><p><i>原子</i> <code><b>(</b></code> <code><b>?</b></code> <code><b>:</b></code> <i>析取</i> <code><b>)</b></code> （非标记子表达式）简单地求值<i>析取</i>且不存储其结果于子匹配。这是纯的词汇分组。
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">本节未完成<br>原因：暂无示例 </td></tr></table>
<h3><span class="mw-headline" id=".E5.9B.9E.E6.BA.AF.E5.BC.95.E7.94.A8">回溯引用</span></h3>
<p><i>DecimalEscape</i> ::
</p>
<dl><dd> <i>DecimalIntegerLiteral</i> [<i>lookahead</i> ∉ <i>DecimalDigit</i>]
</dd></dl>
<p>若 <code><b>\</b></code> 后随首位非 <code>0</code> 的十进制数 <code>N</code> ，则认为该转义序列为<i>回溯引用 (backreference)</i> 。通过在每个数位上调用 <span class="t-lc"><a href="regex_traits/value.html" title="cpp/regex/regex traits/value">std::regex_traits::value</a></span><span class="t-mark">(仅 C++)</span> 并用底 10 算术组合及其结果获得 <code>N</code> 。若 <code>N</code> 大于整个正则表达式中捕获括号的总数，则为错误。
</p><p>回溯引用 <code>\N</code> 作为原子出现时，它匹配当前存储于子匹配数组中第 N 个元素的子串。
</p><p>十进制转义 <code>\0</code> <b>不</b>是回溯引用：它是表示空字符的字符转义。它不能为十进制数所后随。
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">本节未完成<br>原因：暂无示例 </td></tr></table>
<h3><span class="mw-headline" id=".E5.8D.95.E5.AD.97.E7.AC.A6.E5.8C.B9.E9.85.8D">单字符匹配</span></h3>
<p><i>原子</i> <code><b>.</b></code> 匹配并消耗来自输入序列的任一字符，除了<i>行终止符</i>（ <code>U+000A</code> 、 <code>U+000D</code> 、 <code>U+2028</code> 或 <code>U+2029</code> ）
</p><p><i>原子</i> <i>模式字符</i> ，其中<i>模式字符 (PatternCharacter)</i> 为任何<i>源字符 (SourceCharacter)</i> ，<b>除了</b>字符 <code><b>^ $ \ . * + ? ( ) [ ] { } |</b></code> ，匹配并消耗一个来自输入的字符，若它等于此<i>模式字符</i>。
</p><p>这个及所有其他单字符匹配定义如下：
</p>
<div class="t-li1"><span class="t-li">1)</span> 若设置了 <span class="t-lc"><a href="syntax_option_type.html" title="cpp/regex/syntax option type">std::regex_constants::icase</a></span> ，则若 <span class="t-lc"><a href="regex_traits/translate_nocase.html" title="cpp/regex/regex traits/translate nocase">std::regex_traits::translate_nocase</a></span> 的返回值相等则字符相等。<span class="t-mark">(仅 C++)</span></div>
<div class="t-li1"><span class="t-li">2)</span> 否则，若设置了 <span class="t-lc"><a href="syntax_option_type.html" title="cpp/regex/syntax option type">std::regex_constants::collate</a></span> ，则若 <span class="t-lc"><a href="regex_traits/translate.html" title="cpp/regex/regex traits/translate">std::regex_traits::translate</a></span> 的返回值相等则字符相等。<span class="t-mark">(仅 C++)</span></div>
<div class="t-li1"><span class="t-li">3)</span> 否则，若 operator== 返回 true 则字符相等。</div>
<p>每个由转义字符 <code><b>\</b></code> 后随<i>字符转义 (CharacterEscape)</i> 的<i>原子</i>，还有特殊十进制转义 <code><b>\0</b></code> ，匹配消耗一个来自输入的字符，若它等于<i>字符转义</i>所表示的字符。辨识下列字符转义序列：
</p><p><i>CharacterEscape</i> ::
</p>
<dl><dd> <i>ControlEscape</i>
</dd><dd> <code><b>c</b></code> <i>ControlLetter</i>
</dd><dd> <i>HexEscapeSequence</i>
</dd><dd> <i>UnicodeEscapeSequence</i>
</dd><dd> <i>IdentityEscape</i>
</dd></dl>
<p>此处<i>控制转义 (ControlEscape)</i> 为下列五个字符之一： <code><b>f n r t v</b></code>
</p>
<table class="wikitable">

<tr>
<th>控制转义</th>
<th>编码单元</th>
<th>名称
</th></tr>
<tr>
<td> <code><b>f</b></code>
</td>
<td> U+000C
</td>
<td> 换页
</td></tr>
<tr>
<td> <code><b>n</b></code>
</td>
<td> U+000A
</td>
<td> 换行
</td></tr>
<tr>
<td> <code><b>r</b></code>
</td>
<td> U+000D
</td>
<td> 回车
</td></tr>
<tr>
<td> <code><b>t</b></code>
</td>
<td> U+0009
</td>
<td> 水平制表
</td></tr>
<tr>
<td> <code><b>v</b></code>
</td>
<td> U+000B
</td>
<td> 垂直制表
</td></tr></table>
<p><i>控制字母 (ControlLetter)</i> 为任何小写或大写 ASCII 字符，而此字符转义所匹配字符的编码单元等于<i>控制字母</i>的编码单元的值除以 <span class="t-c"><span class="mw-geshi cpp source-cpp"><span class="nu0">32</span></span></span> ，例如 <code><b>\cD</b></code> 和 <code><b>\cd</b></code> 都匹配编码单元 <code>U+0004</code> (EOT) ，因为 'D' 是 <code>U+0044</code> 而 <code>0x44 % 32 == 4</code> 并且 'd' 是 <code>U+0064</code> 而 <code>0x64 % 32 == 4</code> 。
</p><p><i>十六进制转义序列 (HexEscapeSequence)</i> 是字母 <code><b>x</b></code> 后随准确二个<i>十六进制位 (HexDigit)</i> （其中<i>十六进制位</i>是 <code><b>0 1 2 3 4 5 6 7 8 9 a b c d e f A B C D E F</b></code> 之一）。此字符转义所匹配字符的编码单元等于二位十六进制数的数值。
</p><p><i>Unicode转义序列 (UnicodeEscapeSequence)</i> 是字母 <code><b>u</b></code> 后随准确四个<i>十六进制位</i>。此字符转义所匹配字符的编码单元等于此四位十六进制数的数值。若该值不适于此 <span class="t-lc"><a href="basic_regex.html" title="cpp/regex/basic regex">std::basic_regex</a></span> 的 CharT ，则抛出 <span class="t-lc"><a href="regex_error.html" title="cpp/regex/regex error">std::regex_error</a></span> <span class="t-mark">(仅 C++)</span>。
</p><p><i>自身转义 (IdentityEscape)</i> 能为任何非字母数字的字符：例如另一反斜杠。它照原样匹配字符。
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">本节未完成<br>原因：暂无示例 </td></tr></table>
<h3><span class="mw-headline" id=".E5.AD.97.E7.AC.A6.E7.B1.BB">字符类</span></h3>
<p>原子能表示字符类，即它会匹配并消耗一个字符，若该字符属于预定义的字符组之一。
</p><p>字符类能通过字符类转义引入：
</p><p><i>Atom</i> ::
</p>
<dl><dd> <code><b>\</b></code> <i>CharacterClassEscape</i>
</dd></dl>
<p>或直接为
</p><p><i>Atom</i> ::
</p>
<dl><dd> <i>CharacterClass</i>
</dd></dl>
<p>字符类转义是一些常用字符类的简洁写法，如下：
</p>
<table class="wikitable">

<tr>
<th>字符类转义</th>
<th>类名表达式<span class="t-mark">(仅 C++)</span></th>
<th>含义
</th></tr>
<tr>
<td> <code><b>d</b></code>
</td>
<td> <code><b>[[:digit:]]</b></code>
</td>
<td> 数字
</td></tr>
<tr>
<td> <code><b>D</b></code>
</td>
<td> <code><b>[^[:digit:]]</b></code>
</td>
<td> 非数字
</td></tr>
<tr>
<td> <code><b>s</b></code>
</td>
<td> <code><b>[[:space:]]</b></code>
</td>
<td> 空白字符
</td></tr>
<tr>
<td> <code><b>S</b></code>
</td>
<td> <code><b>[^[:space:]]</b></code>
</td>
<td> 非空白字符
</td></tr>
<tr>
<td> <code><b>w</b></code>
</td>
<td> <code><b>[_[:alnum:]]</b></code>
</td>
<td> 字母数字字符及字符 <code><b>_</b></code>
</td></tr>
<tr>
<td> <code><b>W</b></code>
</td>
<td> <code><b>[^_[:alnum:]]</b></code>
</td>
<td> 异于字母数字或 <code><b>_</b></code> 的字符
</td></tr></table><span style="font-size:0.7em; line-height:130%">C++ 中这些字符类转义的准确含义以依赖 locale 的具名字符类定义，而非通过显式列举同 ECMAScript 中的可接受字符。</span>
<p><i>字符类 (CharacterClass)</i> 是方括号环绕的<i>类范围 (ClassRanges)</i> 序列，可选地以取反运算符 <code><b>^</b></code> 开始。若它始于 <code><b>^</b></code> ，则此<i>原子</i>匹配任何<b>不在</b>所有<i>类范围</i>的并所表示的字符集合中的字符。否则，此<i>原子</i>匹配任何<b>在</b>所有<i>类范围</i>的并所表示的字符集合中的字符。
</p><p><i>CharacterClass</i> ::
</p>
<dl><dd> <code><b>[</b></code> <code><b>[</b></code> <i>lookahead ∉ {</i><code><b>^</b></code><i>}]</i> <i>ClassRanges</i> <code><b>]</b></code>
</dd><dd> <code><b>[</b></code> <code><b>^</b></code> <i>ClassRanges</i> <code><b>]</b></code>
</dd></dl>
<p>ClassRanges ::
</p>
<dl><dd> [empty]
</dd><dd> <i>NonemptyClassRanges</i>
</dd></dl>
<p><i>NonemptyClassRanges</i> ::
</p>
<dl><dd> <i>ClassAtom</i>
</dd><dd> <i>ClassAtom</i> <i>NonemptyClassRangesNoDash</i>
</dd><dd> <i>ClassAtom</i> - <i>ClassAtom</i> <i>ClassRanges</i>
</dd></dl>
<p>若非空类范围拥有形式 <code><b><i>ClassAtom</i> - <i>ClassAtom</i></b></code> ，则它匹配来自定义如下的范围的任何字符：<span class="t-mark">(仅 C++)</span>
</p><p>首个<i>类原子 (ClassAtom)</i> 必须匹配单个对照元素 <code>c1</code> ，而第二个<i>类原子</i>必须匹配单个对照元素 <code>c2</code> 。采用下列步骤，测试此范围是否匹配输入字符 <code>c</code> ：
</p>
<div class="t-li1"><span class="t-li">1)</span> 若 <span class="t-lc"><a href="syntax_option_type.html" title="cpp/regex/syntax option type">std::regex_constants::collate</a></span> 不打开，则通过直接比较编码点匹配字符：若 <code>c1 &lt;= c &amp;&amp; c &lt;= c2</code> 则匹配 <code>c</code></div>
<div class="t-li1"><span class="t-li">1)</span> 否则（若启用 <span class="t-lc"><a href="syntax_option_type.html" title="cpp/regex/syntax option type">std::regex_constants::collate</a></span> ）：</div>
<div class="t-li2"><span class="t-li">1)</span> 若启用 <span class="t-lc"><a href="syntax_option_type.html" title="cpp/regex/syntax option type">std::regex_constants::icase</a></span> ，则传递所有三个字符（ <code>c</code> 、 <code>c1</code> 及 <code>c2</code> ）给 <span class="t-lc"><a href="regex_traits/translate_nocase.html" title="cpp/regex/regex traits/translate nocase">std::regex_traits::translate_nocase</a></span></div>
<div class="t-li2"><span class="t-li">2)</span> 否则（若未设置 <span class="t-lc"><a href="syntax_option_type.html" title="cpp/regex/syntax option type">std::regex_constants::icase</a></span> ），则传递所有三个字符（ <code>c</code> 、 <code>c1</code> 及 <code>c2</code> ）给 <span class="t-lc"><a href="regex_traits/translate.html" title="cpp/regex/regex traits/translate">std::regex_traits::translate</a></span></div>
<div class="t-li1"><span class="t-li">2)</span> 用 <span class="t-lc"><a href="regex_traits/transform.html" title="cpp/regex/regex traits/transform">std::regex_traits::transform</a></span> 比较结果字符串，而若 <code>transformed c1 &lt;= transformed c &amp;&amp; transformed c &lt;= transformed c2</code> 则匹配 <code>c</code></div>
<p>按字面对待字符 <code><b>-</b></code> ，若它是下列之一
</p>
<ul><li> <i>类范围</i>的首或末字符
</li><li> 杠分隔范围规定的开始或结尾类原子
</li><li> 立即在杠分隔范围规定之后。
</li><li> 以反斜杠转义为<i>字符转义</i>
</li></ul>
<p>NonemptyClassRangesNoDash ::
</p>
<dl><dd> <i>ClassAtom</i>
</dd><dd> <i>ClassAtomNoDash</i> <i>NonemptyClassRangesNoDash</i>
</dd><dd> <i>ClassAtomNoDash</i> - <i>ClassAtom</i> <i>ClassRanges</i>
</dd></dl>
<p><i>ClassAtom</i> ::
</p>
<dl><dd> <code><b>-</b></code>
</dd><dd> <i>ClassAtomNoDash</i>
</dd><dd> <i>ClassAtomExClass</i><span class="t-mark">(仅 C++)</span>
</dd><dd> <i>ClassAtomCollatingElement</i><span class="t-mark">(仅 C++)</span>
</dd><dd> <i>ClassAtomEquivalence</i><span class="t-mark">(仅 C++)</span>
</dd></dl>
<p>ClassAtomNoDash ::
</p>
<dl><dd> <i>SourceCharacter</i> but not one of <code><b>\ or ] or -</b></code>
</dd><dd> <code><b>\</b></code> <i>ClassEscape</i>
</dd></dl>
<p>每个<i>无杠类原子 (ClassAtomNoDash)</i> 表示单个字符——原状的<i>源字符</i>或转义如下的字符：
</p><p>ClassEscape ::
</p>
<dl><dd> <i>DecimalEscape</i>
</dd><dd> <code><b>b</b></code>
</dd><dd> <i>CharacterEscape</i>
</dd><dd> <i>CharacterClassEscape</i>
</dd></dl>
<p>特殊的<i>类转义 (ClassEscape)</i> <code><b>\b</b></code> 产生匹配编码单元 U+0008 （退格）的字符集。在<i>字符类</i>外，它是词边界<i>断言</i>。
</p><p><i>字符类</i>内， <code><b>\B</b></code> 的使用和任何回溯引用（异于零的<i>十进制转义</i>）都是错误。
</p><p>为将字符 <code><b>-</b></code> 和 <code><b>]</b></code> 当做原子，一些情形中需要转义它们。其他拥有在<i>字符类</i>外的特殊含义的字符，例如 <code><b>*</b></code> 或 <code><b>?</b></code> ，不需要转义。
</p>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">本节未完成<br>原因：暂无示例 </td></tr></table>
<h3><span class="mw-headline" id=".E5.9F.BA.E4.BA.8E_POSIX_.E7.9A.84.E5.AD.97.E7.AC.A6.E7.B1.BB">基于 POSIX 的字符类</span></h3>
<p>这些字符类是对 ECMAScript 文法的扩展，并等价于 POSIX 正则表达式中找到的字符类。
</p><p>ClassAtomExClass<span class="t-mark">(仅 C++)</span> ::
</p>
<dl><dd> <code><b>[:</b></code> <i>ClassName</i> <code><b>:]</b></code>
</dd></dl>
<p>表示所有具名字符类<i>类名 (ClassName)</i> 中的成员。仅若 <span class="t-lc"><a href="regex_traits/lookup_classname.html" title="cpp/regex/regex traits/lookup classname">std::regex_traits::lookup_classname</a></span> 对此名称返回非零字符串，名称才合法。如 <span class="t-lc"><a href="regex_traits/lookup_classname.html" title="cpp/regex/regex traits/lookup classname">std::regex_traits::lookup_classname</a></span> 中描述，保证辨识下列名称： <code><b>alnum, alpha, blank, cntrl, digit, graph, lower, print, punct, space, upper, xdigit, d, s, w</b></code> 。额外的名称（如日文中的 <code><b>jdigit</b></code> 或 <code><b>jkanji</b></code> ）可为系统提供的 locale 提供，或实现为用户定义的扩展：
</p><p>ClassAtomCollatingElement<span class="t-mark">(仅 C++)</span> ::
</p>
<dl><dd> <code><b>[.</b></code> <i>ClassName</i> <code><b>.]</b></code>
</dd></dl>
<p>表示具名对照元素，它可表示单个字符，或在感染的 locale 下作为单个单位对照的字符序列，例如 <code>[.tilde.]</code> 或捷克文中的 <code>[.ch.]</code> 。仅若 <span class="t-lc"><a href="regex_traits/lookup_collatename.html" title="cpp/regex/regex traits/lookup collatename">std::regex_traits::lookup_collatename</a></span> 不是空字符串名称才合法。
</p><p>使用 <span class="t-lc"><a href="syntax_option_type.html" title="cpp/regex/syntax option type">std::regex_constants::collate</a></span> 时，始终能以对照元素为范围的端点（例如匈牙利文中的 <code>[[.dz.]-g]</code> ）。
</p><p>ClassAtomEquivalence<span class="t-mark">(仅 C++)</span> ::
</p>
<dl><dd> <code><b>[=</b></code> <i>ClassName</i> <code><b>=]</b></code>
</dd></dl>
<p>表示与具名对照元素相同的等价类的所有成员字符，即其初等对照关键与对照元素<i>类名</i>所拥有者相同的字符。仅若 <span class="t-lc"><a href="regex_traits/lookup_collatename.html" title="cpp/regex/regex traits/lookup collatename">std::regex_traits::lookup_collatename</a></span> 对该名称返回非空字符串，且 <span class="t-lc"><a href="regex_traits/transform_primary.html" title="cpp/regex/regex traits/transform primary">std::regex_traits::transform_primary</a></span> 对调用 <span class="t-lc"><a href="regex_traits/lookup_collatename.html" title="cpp/regex/regex traits/lookup collatename">std::regex_traits::lookup_collatename</a></span> 的结果的返回值不是空字符串，名称才合法。
</p><p>初等排序关键是忽略大小写、标音符或本地环境限定裁剪的关键；故例如 <code>[[=a=]]</code> 匹配任何这些字符之一： <code>a, À, Á, Â, Ã, Ä, Å, A, à, á, â, ã, ä</code> 和 <code>å</code> 。
</p><p>ClassName<span class="t-mark">(仅 C++)</span> ::
</p>
<dl><dd> ClassNameCharacter
</dd><dd> ClassNameCharacter ClassName
</dd></dl>
<p>ClassNameCharacter<span class="t-mark">(仅 C++)</span> ::
</p>
<dl><dd> <i>SourceCharacter</i> 但非 <code><b>. = :</b></code> 之一
</dd></dl>
<table class="metadata plainlinks ambox mbox-small-left ambox-notice" style=""><tr><td class="mbox-empty-cell"></td><td class="mbox-text" style="">本节未完成<br>原因：暂无示例 </td></tr></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 4764/1000000
Preprocessor generated node count: 13105/1000000
Post‐expand include size: 91992/2097152 bytes
Template argument size: 33550/2097152 bytes
Highest expansion depth: 19/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_zh_:pcache:idhash:10252-0!*!0!!zh!*!zh!* and timestamp 20190315094652 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    来自“<a href="https://zh.cppreference.com/mwiki/index.php?title=cpp/regex/ecmascript&amp;oldid=56864">https://zh.cppreference.com/mwiki/index.php?title=cpp/regex/ecmascript&amp;oldid=56864</a>”                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>导航</h5>
            <ul><li><a href="https://zh.cppreference.com/w/cpp/regex/ecmascript">Online version</a></li><li>Offline version retrieved 2019-08-25 10:54.</li></ul></div>
                        <ul id="footer-info">
                                    <li id="footer-info-lastmod"> 本页面最后修改于2018年7月7日 (星期六) 09:55。</li>
                                    <li id="footer-info-viewcount">此页面已被浏览过1,626次。</li>
                            </ul>
                    </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../../../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.MathJax","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../../../common/site_scripts.js"></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 2.056 secs. -->
	</body>
<!-- Cached 20190315094652 -->
</html>