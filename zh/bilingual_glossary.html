<!DOCTYPE html>
<html lang="zh" dir="ltr" class="client-nojs">
<head>
<title>双语术语表</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.21.2">
<link rel="shortcut icon" href="../common/favicon.ico">
<link rel="stylesheet" href="../common/ext.css">
<meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="../common/site_modules.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}#toc{display:none}.editsection{display:none}
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-css:7:15cea3ec788a65b5187d4018eed543bf */</style>

<script src="../common/startup_scripts.js"></script>
<script>if(window.mw){
mw.config.set({"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":false,"wgNamespaceNumber":0,"wgPageName":"bilingual_glossary","wgTitle":"bilingual glossary","wgCurRevisionId":51247,"wgArticleId":8410,"wgIsArticle":true,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":[],"wgBreakFrames":false,"wgPageContentLanguage":"zh","wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"zh","wgMonthNames":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgMonthNamesShort":["","1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],"wgRelevantPageName":"bilingual_glossary","wgUserVariant":"zh","wgRestrictionEdit":[],"wgRestrictionMove":[]});
}</script><script>if(window.mw){
mw.loader.implement("user.options",function(){mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":0,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":0,"showtoolbar":1,"skin":"cppreference2","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,
"watchlistdays":3,"watchlisthideanons":0,"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"zh","language":"zh","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false,"gadget-MathJax":1,"gadget-ColiruCompiler":1});;},{},{});mw.loader.implement("user.tokens",function(){mw.user.tokens.set({"editToken":"+\\","patrolToken":false,"watchToken":false});;},{},{});
/* cache key: mwiki1-mwiki_zh_:resourceloader:filter:minify-js:7:258d7cd6aa9aa67dee25e01fb6a9e505 */
}</script>
<script>if(window.mw){
mw.loader.load(["mediawiki.page.startup","mediawiki.legacy.wikibits","mediawiki.legacy.ajax"]);
}</script>
<style type="text/css">/*<![CDATA[*/
.source-text {line-height: normal;}
.source-text li, .source-text pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for text
 * CSS class: source-text, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.text.source-text .de1, .text.source-text .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.text.source-text  {font-family:monospace;}
.text.source-text .imp {font-weight: bold; color: red;}
.text.source-text li, .text.source-text .li1 {font-weight: normal; vertical-align:top;}
.text.source-text .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.text.source-text .li2 {font-weight: bold; vertical-align:top;}
.text.source-text .ln-xtra, .text.source-text li.ln-xtra, .text.source-text div.ln-xtra {background-color: #ffc;}
.text.source-text span.xtra { display:block; }

/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/mwiki/skins/cppreference2/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-bilingual_glossary skin-cppreference2 action-view">
        <!-- header -->
        <!-- /header -->
        <!-- content -->
<div id="cpp-content-base">
            <div id="content">
                <a id="top"></a>
                <div id="mw-js-message" style="display:none;"></div>
                                <!-- firstHeading -->
<h1 id="firstHeading" class="firstHeading">双语术语表</h1>
                <!-- /firstHeading -->
                <!-- bodyContent -->
                <div id="bodyContent">
                                        <!-- tagline -->
                    <div id="siteSub">来自cppreference.com</div>
                    <!-- /tagline -->
                                        <!-- subtitle -->
                    <div id="contentSub"></div>
                    <!-- /subtitle -->
                                                            <!-- bodycontent -->
                    <div id="mw-content-text" lang="zh" dir="ltr" class="mw-content-ltr"><p><br>
中/英文术语对照表。
</p>
<table class="wikitable sortable">

<tr>
<th style="text-align: left"> 英文
</th>
<th style="text-align: left"> 中文
</th>
<th style="text-align: left"> 解释
</th>
<th style="text-align: left"> 使用建议
</th>
<th style="text-align: left"> 引用
</th></tr>
<tr>
<td> abstract class
</td>
<td> 抽象类
</td>
<td> 【类型】禁止作为全派生对象的类型，但可作为基类
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>abstract-declarator</i>
</td>
<td> <i>抽象声明符</i>
</td>
<td> 【文法】没有标识符部分的声明符，指定类型的指针、引用、数组和函数方面的性质
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>abstract-pack-declarator</i>
</td>
<td> <i>抽象包声明符</i>
</td>
<td> 【文法】抽象声明符的包展开式，其核心部分为“<span class="t-c"><span class="mw-geshi text source-text">...</span></span>”，但不允许有括号和尾部返回类型部分
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> access
</td>
<td> 访问
</td>
<td>
<p>【执行】（运行时）读取或修改内存位置中的值 <br>
【语义】在源代码中使用某个经声明的实体，遵循作用域和名字查找规则，重载解析规则和访问检查规则 <br>
【语法】将类成员标记为 <span class="t-c"><span class="mw-geshi text source-text">private</span></span>、<span class="t-c"><span class="mw-geshi text source-text">protected</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">public</span></span> 的状况
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> access check
</td>
<td> 访问检查
</td>
<td> 【语义】在名字查找和重载解析之后，检查类的成员名是否允许访问
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> access control
</td>
<td> 访问控制
</td>
<td> 【语义】通过对类成员的访问进行安排以实现封装的行为
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>access-specifier</i> <br> access specifier
</td>
<td> <i>访问说明符</i> <br> 访问说明符
</td>
<td> 【文法】关键字 <span class="t-c"><span class="mw-geshi text source-text">public</span></span>，<span class="t-c"><span class="mw-geshi text source-text">protected</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">private</span></span>，在<i>成员说明（member-specification）</i>和<i>基类说明符（base-specifier）</i>中使用
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> acquire
</td>
<td> 获取
</td>
<td> 【内存模型】三种同步操作的一种，可以和释放（release）操作构成“同步于（synchronized with）”关系等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> active member
</td>
<td> 活跃成员
</td>
<td> 【对象】联合对象的当前有效的非静态成员
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> active handler
</td>
<td> 活跃（异常）处理器
</td>
<td> 【异常】异常处理器已完成捕获且尚未退出
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> addition operator
</td>
<td> 加法运算符
</td>
<td> 【语法】二元 <span class="t-c"><span class="mw-geshi text source-text">+</span></span>，<span class="t-c"><span class="mw-geshi text source-text">operator+</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>additive-expression</i>
</td>
<td> <i>加法性表达式</i>
</td>
<td> 【文法】二元加法和减法或更高优先级的表达式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> additive operator
</td>
<td> 加法性运算符
</td>
<td> 【语法】包括二元加法和减法运算符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> address
</td>
<td> 地址
</td>
<td> 【对象】指针的值，每个字节有一个独立的地址
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> address-of operator
</td>
<td> 取地址运算符
</td>
<td> 【语法】一元 <span class="t-c"><span class="mw-geshi text source-text">operator&amp;</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> aggregate
</td>
<td> 聚合
</td>
<td> 【类型】可以进行聚合初始化的类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> aggregate initialization
</td>
<td> 聚合初始化
</td>
<td> 【语法】用花括号初始化式列表不经由构造函数而依次对其成员进行初始化
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> algorithm
</td>
<td> 算法
</td>
<td>
<p>以一定步骤达成某种运算目的的程序执行流程 <br>
【标准库】以迭代器（或范围）进行参数化的函数模板
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> alias
</td>
<td> 别名
</td>
<td>
<p>【语法】命名空间、类型或对象的其他名字。类型的别名称为“typedef 名” <br>
【实现】对同一个对象产生多种访问路径，可能导致丧失某些优化潜力
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>alias-declaration</i>
</td>
<td> <i>别名声明式</i>
</td>
<td> 【文法】用 <span class="t-c"><span class="mw-geshi text source-text">using</span></span> 关键字定义类型别名
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> alias template
</td>
<td> 别名模板
</td>
<td> 【语法】模板化的别名声明式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> alignment
</td>
<td> 对齐
</td>
<td> 【对象】类型或对象的对齐要求的值，为 2 的幂
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> alignment requirement
</td>
<td> 对齐要求
</td>
<td> 【对象】类型或对象要求在内存中以特定的对齐值的整数倍地址位置放置
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>alignment-specifier</i>
</td>
<td> <i>对齐说明符</i>
</td>
<td> 【文法】用关键字 <span class="t-c"><span class="mw-geshi text source-text">alignas</span></span> 指定对齐要求为与某个类型相同或为某个对齐值
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> allocate
</td>
<td> 分配
</td>
<td> 【对象】分配动态内存，或某种受管理的资源
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> allocated type
</td>
<td> 被分配的类型
</td>
<td> 【语法】new 表达式中的类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> allocation function
</td>
<td> 分配函数
</td>
<td> 【语法】<span class="t-c"><span class="mw-geshi text source-text">operator new</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">operator new[]</span></span>。
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> allocator
</td>
<td> 分配器
</td>
<td> 【标准库】提供内存模型的抽象并负责内存资源的分配和回收的组件
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> alternative token
</td>
<td> 替代记号
</td>
<td> 【词法】某些运算符或标点符号的可以等价地换用的另一种写法，又称为“二联符（digraph）”
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> ambiguity
</td>
<td> 歧义
</td>
<td> 【文法】两种产生式出现冲突 <br>
<p>【语义】名字查找中出现源于多继承的冲突 <br>
【语义】重载解析中无法区分函数重载的匹配等级
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> amortized constant
</td>
<td> 摊销常量
</td>
<td> 【执行】算法或操作的复杂度，以长期看是常量时间，但偶尔出现非常量时间的操作
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> AND
</td>
<td> 与
</td>
<td> 【运算】布尔函数
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>and-expression</i>
</td>
<td> <i>与表达式</i>
</td>
<td> 【文法】按位 AND 操作或更高优先级的表达式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> anonymous union
</td>
<td> 匿名联合
</td>
<td> 【语法】既未提供类型名字也未声明变量名字的联合声明式，声明一个隐含的联合对象
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> appertain to
</td>
<td> 属于
</td>
<td> 称某个特性标注<i>属于</i>某种语言构造或实体
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> apply
</td>
<td> 实施，运用
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> apply to
</td>
<td> 适用于
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> arbitrary-positional stream
</td>
<td> 可任意定位流
</td>
<td> 【标准库】可以 <code>seek</code> 的流
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> architecture
</td>
<td> 架构，体系结构
</td>
<td> 【实现】CPU 等设备的总体性质
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> argument
</td>
<td> 实参
</td>
<td> 【语法】各种参数化场合（函数，模板，函数式宏等）中，使用参数化实体时所提供的逗号分隔列表中的一项
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> argument-dependent name lookup
</td>
<td> 依赖于实参的名字查找
</td>
<td> 【语义】在未限定的函数调用表达式中，考虑所出现的所有（函数或模板的）实参所在的命名空间来查找被调用的函数
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> argument substitution
</td>
<td> 实参代换
</td>
<td> 【预处理】调用函数式宏时，将宏的定义中的形参替换为实参记号序列
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> arithmetic exception
</td>
<td> 算术异常
</td>
<td> 【实现】某些算术运算可能引发的异常，如除零，溢出和浮点异常等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> arithmetic type
</td>
<td> 算术类型
</td>
<td> 【类型】包括整数和浮点类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> array
</td>
<td> 数组
</td>
<td> 【类型】连续排列的同类型对象，可以有多维数组
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> array bound
</td>
<td> 数组边界
</td>
<td> 【类型】已知或位置的数组的元素个数
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> array element
</td>
<td> 数组元素
</td>
<td> 【对象】数组的子对象
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> array of N T
</td>
<td> T 的 N 元素数组
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> array of unknown bound of T
</td>
<td> T 的边界未知的数组
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> array-to-pointer conversion
</td>
<td> 数组向指针转换
</td>
<td> 【语义】衰变转换之一，每当需要纯右值时都会实施该转换
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> arrow operator
</td>
<td> 箭头运算符
</td>
<td> 【语法】即指针成员运算符 <span class="t-c"><span class="mw-geshi text source-text">operator-&gt;</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> as-if rule
</td>
<td> “如同”规则
</td>
<td> 【语义】根据“可观察行为”所给出的规则
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>asm-definition</i>
</td>
<td> <i>汇编定义式</i>
</td>
<td> 【文法】编写嵌入式汇编的语言构造
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> assembler
</td>
<td> 汇编器，汇编
</td>
<td> 【实现】配合编译器产生特定体系结构的机器代码的工具
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> assertion
</td>
<td> 断言
</td>
<td> 【语义】声称某个表达式必定为真，由实现在运行时或编译时予以检查
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> assignment
</td>
<td> 赋值
</td>
<td> 【语法】赋值表达式，将变量左值所代表的对象的值改变为所提供的表达式的值
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>assignment-expression</i>
</td>
<td> <i>赋值表达式</i>
</td>
<td> 【文法】赋值和组合赋值操作，以及更高优先级的各种运算的表达式，还用于一同代表条件表达式和 throw 表达式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>assignment-operator</i> <br> assignment operator
</td>
<td> <i>赋值运算符</i> <br> 赋值运算符
</td>
<td> 【文法】赋值和组合赋值的运算符：<span class="t-c"><span class="mw-geshi text source-text">=</span></span>，<span class="t-c"><span class="mw-geshi text source-text">*=</span></span>，…… <br>
<p>【语法】各种赋值运算符函数，包括复制赋值运算符和移动赋值运算符
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> associated class
</td>
<td> 关联类
</td>
<td> 【语义】在 ADL 中所确定的相关类
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> associated namespace
</td>
<td> 关联命名空间
</td>
<td> 【语义】在 ADL 中所确定的相关命名空间
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> associative container
</td>
<td> 关联容器
</td>
<td> 【标准库】提供键-值映射风格接口并维持有序性的容器
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> asynchronous provider
</td>
<td> 异步提供器
</td>
<td> 【标准库】异步向某个共享状态提供值的实体，如 <span class="t-c"><span class="mw-geshi text source-text">promise</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">task</span></span> 等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> asynchronous return object
</td>
<td> 异步返回对象
</td>
<td> 【标准库】在共享状态上阻塞以获取其结果的实体，如 <span class="t-c"><span class="mw-geshi text source-text">future</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> atomic operation
</td>
<td> 原子性操作，原子操作
</td>
<td> 【内存模型】带有可见性和顺序性语义约束的标量内存操作
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> atomic type
</td>
<td> 原子性类型，原子类型
</td>
<td> 【标准库】提供原子性操作的类模板的特例
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>attribute</i><br>attribute
</td>
<td> <i>特性</i><br>特性，特性标注
</td>
<td> 【文法】<i>特性说明符列表</i>中的一项，可以带有实参部分<br>
<p>【语法】为各种语言构造进行特定标注，语法形式一般为 <span class="t-c"><span class="mw-geshi text source-text">[[ ns::attr1, attr2... ]]</span></span>
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>attribute-declaration</i>
</td>
<td> <i>特性声明式</i>
</td>
<td> 【文法】仅包含特性标注的声明式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>attribute-specifier</i>
</td>
<td> <i>特性说明符</i>
</td>
<td> 【文法】以双方括号（<span class="t-c"><span class="mw-geshi text source-text">[[ ]]</span></span>）包围的特性标注的列表，其中可以在开头指定一个公用的特性命名空间 using 前缀
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>attribute-token</i>
</td>
<td> <i>特性记号</i>
</td>
<td> 【文法】某个特定特性的名字，可以带有命名空间前缀
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> atomatic storage duration
</td>
<td> 自动存储持续期
</td>
<td> 【语义】变量的生存期随运行栈的各级结构的进入和退出自动开始和结束
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> atomatic variable
</td>
<td> 自动变量
</td>
<td> 【语义】具有自动存储持续期的变量
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> backslash
</td>
<td> 反斜杠
</td>
<td> 【文法】字符 <span class="t-c"><span class="mw-geshi text source-text">\</span></span>，作为转义序列的开头字符和逻辑行拼接字符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> base characteristic
</td>
<td> 基础特征
</td>
<td> 【标准库】类型特征的基类，为 <span class="t-c"><span class="mw-geshi text source-text">integral_constant</span></span> 模板的特例
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> base class
</td>
<td> 基类
</td>
<td> 【语法】定义类派生与其他的类
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> base class initializer
</td>
<td> 基类初始化式
</td>
<td> 【语法】在构造函数的<i>构造函数初始化式（ctor-initializer）</i>部分中用以初始化基类子对象的初始化式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> base class subobject
</td>
<td> 基类子对象
</td>
<td> 【对象】派生类对象中的基类部分，大小可能为零
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>base-clause</i>
</td>
<td> <i>基子句</i>
</td>
<td> 【文法】<i>类头（class-head）</i>中指定基类的部分，包括冒号和基类列表
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>base-specifier</i>
</td>
<td> <i>基说明符</i>
</td>
<td> 【文法】<i>基子句</i>中指定一项基类的类型，可选包括其特性标注、访问说明符和是否为 <span class="t-c"><span class="mw-geshi text source-text">virtual</span></span>，类型可以是带有限定的<i>类名（class-name）</i>或 ‘’decltype-说明符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> basic character set
</td>
<td> 基本字符集
</td>
<td> 【词法】基本源字符集或基本执行字符集
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> basic source character set
</td>
<td> 基本源字符集
</td>
<td> 【词法】96 个指定的字符：a-zA-Z0-9_{}[]#()&lt;&gt;%:;.?*+-/^&amp;|~!=,\"'，加上 \t、\v、\f、\n 和空格
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> basic execution character set <br> basic execution wide-character set
</td>
<td> 基本执行字符集 <br> 基本执行宽字符集
</td>
<td> 【词法】基本源字符集加上 \a、\b、\r 和 \0
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> behavior
</td>
<td> 行为
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> best viable function
</td>
<td> 最佳可行函数
</td>
<td> 【语义】重载解析中所确定的具有最好的隐式转换序列的函数
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> binary fold
</td>
<td> 二元折叠
</td>
<td> 【语法】有两个表达式参与的折叠表达式 <span class="t-c"><span class="mw-geshi text source-text">exp1 op ... op exp2</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> binary left fold
</td>
<td> 二元左折叠
</td>
<td> 【语法】右侧表达式为未展开的形参包的二元折叠表达式 <span class="t-c"><span class="mw-geshi text source-text">arg op ... op pack</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>binary-literal</i>
</td>
<td> <i>二进制字面量</i>
</td>
<td> 【文法】以 <span class="t-c"><span class="mw-geshi text source-text">0b</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">0B</span></span> 开头的整数字面量，允许 <span class="t-c"><span class="mw-geshi text source-text">​0​</span></span>，<span class="t-c"><span class="mw-geshi text source-text">1</span></span> 和分隔符 <span class="t-c"><span class="mw-geshi text source-text">'</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> binary operator
</td>
<td> 二元运算符
</td>
<td> 【语法】有两个操作数的运算符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> binary right fold
</td>
<td> 二元右折叠
</td>
<td> 【语法】左侧表达式为未展开的形参包的二元折叠表达式 <span class="t-c"><span class="mw-geshi text source-text">pack op ... op arg</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> binding of default argument
</td>
<td> 默认实参的绑定关系
</td>
<td> 【语义】默认实参表达式中使用的实体于声明时确定
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bit
</td>
<td> 位
</td>
<td> 【内存】最小信息单元，0 或 1
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bit-field
</td>
<td> 位域
</td>
<td> 【对象】整数或枚举类型，指定了位长度的非静态数据成员，零长度的位域用于分隔内存位置
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bitmask type
</td>
<td> 位掩码类型
</td>
<td> 【标准库】某些标准库类型提供位的组合操作，以作为控制行为的标记值
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bitset
</td>
<td> 位集合
</td>
<td> 【标准库】定长的位集合类
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bitwise AND operator
</td>
<td> 按位与运算符，按位 AND 运算符
</td>
<td> 【语法】二元 <span class="t-c"><span class="mw-geshi text source-text">operator&amp;</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bitwise exclusive OR operator
</td>
<td> 按位异或运算符，按位 XOR 运算符
</td>
<td> 【语法】二元 <span class="t-c"><span class="mw-geshi text source-text">operator^</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bitwise (inclusive) OR operator
</td>
<td> 按位或运算符，按位 OR 运算符
</td>
<td> 【语法】二元 <span class="t-c"><span class="mw-geshi text source-text">operator|</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bitwise negation operator
</td>
<td> 按位取反运算符
</td>
<td> 【语法】一元 <span class="t-c"><span class="mw-geshi text source-text">operator~</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bitwise shift operator
</td>
<td> 位移运算符
</td>
<td> 【语法】左移和右移，二元 <span class="t-c"><span class="mw-geshi text source-text">operator&lt;&lt;</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">operator&gt;&gt;</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> block
</td>
<td> 块，代码块，阻塞
</td>
<td> 【语法】函数体中以花括号为边界的语句序列，提供块作用域并整体作为单个语句 <br>
<p>【执行】线程等待某个条件的达成
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>block-declaration</i>
</td>
<td> <i>块声明式</i>
</td>
<td> 【文法】可以在块语句中出现的声明式（作为<i>声明式语句（declaration-statement）</i>）
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> block scope
</td>
<td> 块作用域
</td>
<td> 【语义】由块语句所提供的作用域，默认的块作用域局部变量具有自动存储持续期
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> block statement
</td>
<td> 块语句
</td>
<td> 【语法】带有花括号边界的语句序列，<i>复合语句（compound-statement）</i>，提供块作用域并整体作为单个语句
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> block with forward progress guarantee delegation
</td>
<td> 带有向前进展保证委托的阻塞
</td>
<td> 【执行】对并行算法在线程池中分派任务并阻塞的行为的抽象描述
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> boolean
</td>
<td> 布尔
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> boolean conversion
</td>
<td> 布尔转换
</td>
<td> 【语义】将算术、无作用域枚举、指针和成员指针值转换为 <span class="t-c"><span class="mw-geshi text source-text">bool</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>boolean-literal</i>
</td>
<td> <i>布尔字面量</i>
</td>
<td> 【文法】字面量关键字 <span class="t-c"><span class="mw-geshi text source-text">true</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">false</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> boolean value
</td>
<td> 布尔值
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bound argument
</td>
<td> 已绑定实参
</td>
<td> 【标准库】<span class="t-c"><span class="mw-geshi text source-text">bind</span></span> 函数存储到其返回的函数对象中的实参值
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>brace-or-equal-initializer</i>
</td>
<td> <i>花括号或等号初始化式</i>
</td>
<td> 【文法】包括花括号和等号两种形式的初始化式，但不包括构造函数参数列表形式，可以用于所有初始化场合
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>braced-init-list</i>
</td>
<td> <i>花括号初始化式列表</i>
</td>
<td> 【文法】带有花括号的初始化式的逗号分隔列表
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> bucket
</td>
<td> 桶
</td>
<td> 【标准库】无序关联容器中的存储管理单位，存储具有相同散列值的元素
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> built-in operator
</td>
<td> 内建运算符
</td>
<td> 【语义】作为语言规则的一部分而提供的运算符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> byte
</td>
<td> 字节
</td>
<td> 【内存】内存的最小可寻址单元，至少 8 位
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cache
</td>
<td> 高速缓存
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> call
</td>
<td> 调用
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> call signature
</td>
<td> 调用签名
</td>
<td> 【标准库】<span class="t-c"><span class="mw-geshi text source-text">function</span></span> 等组件用以指定所支持的函数签名，即函数类型，没有函数名和形参名
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> call wrapper
</td>
<td> 调用包装器
</td>
<td> 【标准库】<span class="t-c"><span class="mw-geshi text source-text">function</span></span>，<span class="t-c"><span class="mw-geshi text source-text">bind</span></span> 等类型的对象，保存一个可调用对象为其目标对象，并提供向目标的调用操作的转发
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> call wrapper type
</td>
<td> 调用包装器类型
</td>
<td> 【标准库】<span class="t-c"><span class="mw-geshi text source-text">function</span></span> 等类型，提供向其目标对象的调用转发
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> callable object
</td>
<td> 可调用对象
</td>
<td> 【标准库】可调用类型的对象，可作为调用包装器的目标对象
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> callable type
</td>
<td> 可调用类型
</td>
<td> 【标准库】函数对象类型或者成员指针类型，可以用函数调用语法进行调用
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> candidate function
</td>
<td> 候选函数
</td>
<td> 【语义】重载解析中，根据名字查找所找到的所有函数声明式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> capture
</td>
<td> 捕获，捕获式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>capture</i>
</td>
<td> <i>捕获式</i>
</td>
<td> 【文法】lambda 表达式的<i>捕获式列表（capture-list）</i>中的一项
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> captured by copy
</td>
<td> 复制捕获
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> captured by reference
</td>
<td> 引用捕获
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>capture-default</i>
</td>
<td> <i>默认捕获符</i>
</td>
<td> 【文法】指定 lambda 表达式的默认捕获方式，可以为 <span class="t-c"><span class="mw-geshi text source-text">&amp;</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">{{{1}}}</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> carries dependency attribute
</td>
<td> 传递依赖特性标注
</td>
<td> 【语法】标注函数的返回值或形参在函数中已经实现为提供<i>按依赖顺序早于</i>关系，编译器不需要专门为其添加指令以保护依赖关系了
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> carry a dependency to
</td>
<td> 传递依赖给
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> case label
</td>
<td> case 标号
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cast
</td>
<td> 强制转换
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cast away constness
</td>
<td> 强制移除常量性
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>cast-expression</i>
</td>
<td> <i>强制转换表达式</i>
</td>
<td> 【文法】C 风格强制类型转换，也代表所有其他一元表达式的语法范畴
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> catch
</td>
<td> 捕获
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> catch clause
</td>
<td> catch 子句，捕获子句
</td>
<td> 【语法】异常处理器的 <span class="t-c"><span class="mw-geshi text source-text">catch</span></span> 及其异常形参声明
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> char-like object
</td>
<td> 字符式对象
</td>
<td> 【标准库】字符式类型的对象，称为 <span class="t-c"><span class="mw-geshi text source-text">basic_string</span></span> 中的<i>字符</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> char-like type
</td>
<td> 字符式类型
</td>
<td> 【标准库】即非数组 POD 类型，允许作为 <span class="t-c"><span class="mw-geshi text source-text">basic_string</span></span> 的值类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> character
</td>
<td> 字符
</td>
<td> 【标准库】字符串库、本地化库、I/O 库和正则表达式库中的值类型的对象
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> character array initialization
</td>
<td> 字符数组初始化
</td>
<td> 【语法】用字符串字面量初始化字符数组
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> character container type
</td>
<td> 字符容器类型
</td>
<td> 【标准库】用于代表字符的任何 POD 类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>character-literal</i>
</td>
<td> <i>字符字面量</i>
</td>
<td> 【文法】带有<i>编码前缀（encoding-prefix）</i>的一个单引号包围的字符序列，允许出现<i>转义序列（escape-sequence）</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> character set
</td>
<td> 字符集
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> character type
</td>
<td> 字符类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class
</td>
<td> 类
</td>
<td> 【类型】自定义类型，可以包含数据成员、成员函数、嵌套类型等成员，提供作用域，包括类、结构和联合
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class declaration
</td>
<td> 类声明式
</td>
<td> 【语法】即类定义式，将类声明为完整类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class definition
</td>
<td> 类定义式
</td>
<td> 【语法】即类声明式，将类声明为完整类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class granding friendship
</td>
<td> 授予友元关系的类
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>class-head</i>
</td>
<td> <i>类头</i>
</td>
<td> 【文法】类定义式的<i>类说明符（class-specifier）</i>中的花括号之前的部分，包括<i>类关键字（class-key）</i>，类名部分，<i>类虚说明符（class-virt-specifier）</i>和<i>基子句（base-clause）</i>等各项
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>class-key</i>
</td>
<td> <i>类关键字</i>
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">class</span></span>，<span class="t-c"><span class="mw-geshi text source-text">struct</span></span>，<span class="t-c"><span class="mw-geshi text source-text">union</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class member
</td>
<td> 类成员
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class member access expression
</td>
<td> 类成员访问表达式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class member access operator
</td>
<td> 类成员访问运算符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>class-name</i>
</td>
<td> <i>类名</i>
</td>
<td> 【文法】类名，<i>标识符（identifier）</i>或<i>简单模板标识（simple-template-id）</i>，不带有作用域限定；类的 <i>typedef-名</i>也是<i>类名</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class scope
</td>
<td> 类作用域
</td>
<td> 【语义】类提供作用域
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>class-specifier</i> <br> class specifier
</td>
<td> <i>类说明符</i> <br> <i>类说明符</i>
</td>
<td> 【文法】类定义式的类型部分，包括<i>类头（class-head）</i>和花括号包围的<i>成员说明（member-specifier）</i>的序列
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class template
</td>
<td> 类模板
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class template argument deduction
</td>
<td> 类模板实参推断
</td>
<td> 【语义】从类模板的构造函数的函数实参推断出模板实参
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class template partial specialization
</td>
<td> 类模板偏特化式
</td>
<td> 【语法】指定类模板对于某个自身也被参数化的实参列表时的定义式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> class template specialization
</td>
<td> 类模板特化式 <br> 类模板特例
</td>
<td> 【语法】指定类模板对于某个特定实参列表时的定义式<br>
<p>【语义】类模板由某个特定实参列表限定后的实体类型；类模板特例是类
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>class-virt-specifier</i>
</td>
<td> <i>类虚说明符</i>
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">final</span></span>，表明类是否可以被派生
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> clause
</td>
<td> 子句
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> closure object
</td>
<td> 闭包对象
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> closure type
</td>
<td> 闭包类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> collating element
</td>
<td> 校排元素
</td>
<td> 【标准库】基于区域（locale）的校排中作为单个字符处理的字符序列，比如 ij 或 ss
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> comma-operator
</td>
<td> 逗号运算符
</td>
<td> 【语法】<span class="t-c"><span class="mw-geshi text source-text">,</span></span>，<span class="t-c"><span class="mw-geshi text source-text">operator,</span></span>，形参列表、实参列表、初始化式列表等场合下的逗号不是运算符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> comment
</td>
<td> 注释，代码注释
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> common initial sequence
</td>
<td> 共同起始序列
</td>
<td> 【对象】两个标准布局结构中，从第一个非静态数据成员开始互相类型（及位域长度）匹配的各个成员
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> common type
</td>
<td> 公共类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> comparision function
</td>
<td> 比较函数
</td>
<td> 【标准库】相等性和关系运算符的运算符函数
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> compatible with
</td>
<td> 与……兼容
</td>
<td> 【标准库】<span class="t-c"><span class="mw-geshi text source-text">shared_ptr</span></span> 的一些模板化的构造、赋值、<span class="t-c"><span class="mw-geshi text source-text">swap</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">reset</span></span> 可以接受的指针实参的类型 Y*
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> compile
</td>
<td> 编译
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> complete object
</td>
<td> 完整对象
</td>
<td> 【对象】不是其他对象的子对象的对象
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> complete type
</td>
<td> 完整类型
</td>
<td> 【类型】并非不完整类型的类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> completely-defined class
</td>
<td> 完全定义的类
</td>
<td> 【语法】类的闭花括号之后，类就被完全定义了
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> complex number
</td>
<td> 复数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> complexity
</td>
<td> 复杂度
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> compliance
</td>
<td> 遵从性
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> component
</td>
<td> 组件
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> composite pointer type
</td>
<td> 合成指针类型
</td>
<td> 【语义】当进行指针比较和条件表达式运算时，需要涉及指针操作数的一种公共类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> compound assignment operator
</td>
<td> 复合赋值运算符，组合赋值运算符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>compound-statement</i> <br> compound statement
</td>
<td> <i>复合语句</i> <br>复合语句，组合语句
</td>
<td> 【文法】带花括号的语句序列，当做一个语句，并提供块作用域，又称“块语句”或“块”
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> compound type
</td>
<td> 复合类型，组合类型
</td>
<td> 【类型】数组，函数，指针，引用，类（包括联合），枚举，成员指针，以及参与类型系统的 cv 限定符等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> concatenation
</td>
<td> 拼接
</td>
<td> 【预处理】在宏的替换列表中将前后两个预处理记号或宏实参拼接成一个预处理记号 <br>
<p>【语法】两个连续的字符串字面量被拼接成一个字符串字面量
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> concept
</td>
<td> 概念
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> concurrent
</td>
<td> 并发的
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> concurrent forward progress guarantee
</td>
<td> 并发向前进展保证
</td>
<td> 【执行】线程终将取得进展，即实现保证会调度这个线程执行
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> concurrency
</td>
<td> 并发， 并发性
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>condition</i>
</td>
<td> <i>条件</i>
</td>
<td> 【文法】任何表达式或带有初始化式的单个变量的声明式，适用于 <span class="t-c"><span class="mw-geshi text source-text">if</span></span>，<span class="t-c"><span class="mw-geshi text source-text">switch</span></span>，<span class="t-c"><span class="mw-geshi text source-text">while</span></span> 和普通 <span class="t-c"><span class="mw-geshi text source-text">for</span></span>；<span class="t-c"><span class="mw-geshi text source-text">do-while</span></span> 的条件不能声明变量所以不是<i>条件</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>conditional-expression</i>
</td>
<td> <i>条件表达式</i>
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">?:</span></span> 运算符的三元表达式，并代表更高优先级的其他表达式范畴
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conditional inclusion
</td>
<td> 条件包含
</td>
<td> 【预处理】由 <span class="t-c"><span class="mw-geshi text source-text">#include</span></span> 等指令控制采用或排除某些源代码行
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conditional operator
</td>
<td> 条件运算符
</td>
<td> 【语法】<span class="t-c"><span class="mw-geshi text source-text">?:</span></span>，不可重载
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conditionally-supported behavior
</td>
<td> 有条件支持的行为
</td>
<td> 【实现】允许编译器作为一种扩展而提供的功能特性
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conflict
</td>
<td> 冲突
</td>
<td> 【执行】两个线程并发读写同一个内存位置
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conjunction
</td>
<td> 合取
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> const safety
</td>
<td> const 安全性
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> const-default-constructible
</td>
<td> 可 const 默认构造的
</td>
<td> 【类型】可以定义默认初始化的变量，类提供默认构造函数，或其成员和基类均有默认初始化式或为可 const 默认构造的
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> const-qualified
</td>
<td> const 限定的
</td>
<td> 【类型】顶层带有 const 限定符的类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> const-volatile-qualified
</td>
<td> const volatile 限定的
</td>
<td> 【类型】顶层带有 const 和 volatile 限定符的类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constant
</td>
<td> 常量
</td>
<td> 【语法】C 语言中称文字直接量为常量，C++ 中称为字面量
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>constant-expression</i> <br> constant expression
</td>
<td> <i>常量表达式</i> <br> 常量表达式
</td>
<td> 【文法】<i>条件表达式</i>，即除赋值、逗号和 <span class="t-c"><span class="mw-geshi text source-text">throw</span></span> 意外的所有表达式 <br>
<p>【语义】进行编译期求值的表达式，用作数组大小、模板实参、case 标号等场合
</p>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constant initialization
</td>
<td> 常量初始化
</td>
<td> 【语义】静态初始化的一种；初始化静态或线程持续期的变量，使其具有编译期即可决定的值
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constant initializer
</td>
<td> 常量初始化式
</td>
<td> 【语义】为对象进行常量初始化的初始化式，常量表达式或者调用 constexpr 构造函数的表达式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constant iterator
</td>
<td> 常量迭代器
</td>
<td> 【标准库】不符合输出迭代器概念的迭代器；表达式 <span class="t-c"><span class="mw-geshi text source-text">{{{1}}}</span></span> 没有定义
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constant subexpression
</td>
<td> 常量子表达式
</td>
<td> 【语义】允许作为条件表达式的子表达式，而条件表达式仍为核心常量表达式的表达式，比如 <span class="t-c"><span class="mw-geshi text source-text">throw</span></span> 等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constexpr constructor
</td>
<td> constexpr 构造函数
</td>
<td> 【语义】参数为字面量类型，不能涉及动态多态，不能有 <span class="t-c"><span class="mw-geshi text source-text">mutable</span></span>，<span class="t-c"><span class="mw-geshi text source-text">goto</span></span>，<span class="t-c"><span class="mw-geshi text source-text">try</span></span> 等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constexpr function
</td>
<td> constexpr 函数
</td>
<td> 【语义】参数和返回类型为字面量类型，不能涉及动态多态，不能有 <span class="t-c"><span class="mw-geshi text source-text">mutable</span></span>，<span class="t-c"><span class="mw-geshi text source-text">goto</span></span>，<span class="t-c"><span class="mw-geshi text source-text">try</span></span> 等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constexpr if statement
</td>
<td> constexpr if 语句
</td>
<td> 【语法】<span class="t-c"><span class="mw-geshi text source-text">if constexpr (...)...</span></span>，根据条件常量的值，其子语句之一为弃用语句
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constexpr specifier
</td>
<td> constexpr 说明符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constituent expression
</td>
<td> 成分表达式
</td>
<td> 【执行】表达式自身，以及表达式中的初始化式列表中的每一项；用于统一定义子表达式的概念
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constness
</td>
<td> 常量性
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> construct
</td>
<td> 语言构造，构造
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> constructor
</td>
<td> 构造函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> consume
</td>
<td> 消费
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> contained value
</td>
<td> 被包含的值
</td>
<td> 【标准库】<span class="t-c"><span class="mw-geshi text source-text">any</span></span>，<span class="t-c"><span class="mw-geshi text source-text">optional</span></span>，<span class="t-c"><span class="mw-geshi text source-text">variant</span></span> 中的值
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> container
</td>
<td> 容器
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> context
</td>
<td> 语境，上下文
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> contextually converted to
</td>
<td> 按语境转换为
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> contiguous container
</td>
<td> 连续容器
</td>
<td> 【标准库】容器的迭代器是随机访问的连续迭代器
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> continue statement
</td>
<td> continue 语句
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> contravariant
</td>
<td> 逆变
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> control line
</td>
<td> 控制行
</td>
<td> 【预处理】预处理指令，除 <span class="t-c"><span class="mw-geshi text source-text">#if</span></span> 等条件指令之外的预处理指令行
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conversion
</td>
<td> 转换，类型转换
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conversion function
</td>
<td> 转换函数
</td>
<td> 【语法】隐式或显式类型转换的成员运算符函数
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>conversion-function-id</i>
</td>
<td> <i>转换函数标识</i>
</td>
<td> 【文法】即转换函数的函数名，由 <span class="t-c"><span class="mw-geshi text source-text">operator</span></span> 和<i>转换类型标识</i>构成
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> conversion rank
</td>
<td> 转换等级
</td>
<td> 【语义】在进行重载解析时，将各种标准转换归类为三种等级：精确匹配，提升和转换
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>conversion-type-id</i>
</td>
<td> <i>转换类型标识</i>
</td>
<td> 【文法】转换函数的类型部分，仅允许类型名和指针、引用修饰，不允许数组或函数等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> converted constant expression
</td>
<td> 经转换的常量表达式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> converting constructor
</td>
<td> 转换构造函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> copy
</td>
<td> 复制，副本
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> copy assignment operator
</td>
<td> 复制赋值运算符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> copy constructor
</td>
<td> 复制构造函数
</td>
<td> 【语法】非模板构造函数，第一个形参类型为 <span class="t-c"><span class="mw-geshi text source-text">X&amp;</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">const X&amp;</span></span>，可以有多个形参，但必须可以用单个实参调用
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> copy elision
</td>
<td> 复制消除
</td>
<td> 【语义】某些情况下编译器略过对象的复制操作而直接将值作为所传递的对象，有时也允许用移动操作代替复制操作
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> copy-initialization
</td>
<td> 复制初始化
</td>
<td> 【语义】等号初始化，以及函数传参和返回，异常捕获和抛出，和聚合成员的初始化为复制初始化；可能调用移动操作
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> core constant expression
</td>
<td> 核心常量表达式
</td>
<td> 【语义】允许进行编译期求值的表达式，不允许未定义行为，不允许 goto 和 throw 等操作，不允许涉及内存操作和 RTTI，不允许调用非 constexpr 函数，使用的变量必须为 constexpr 或字面量类型等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> covariant
</td>
<td> 协变
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> covariant return type
</td>
<td> 协变返回类型
</td>
<td> 【类型】虚函数的返回类型，在其覆盖函数中可以改为某个派生类
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>ctor-initializer</i>
</td>
<td> <i>构造函数初始化式</i>
</td>
<td> 【文法】构造函数的函数体的一部分，冒号后跟着<i>成员初始化式（mem-initializer）</i>的列表
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cv-qualification
</td>
<td> cv 限定性
</td>
<td> 【类型】类型的 cv 限定符修饰的状态，属于类型系统的一部分；类成员、函数形参、引用和指针和成员指针的各级都可以被限定
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> current instantiation
</td>
<td> 当前实例化
</td>
<td> 【类型】类模板或类模板的嵌套类的作用域中，类模板或嵌套类的注入类名，主模板中带有其模板形参列表的类模板名，或特化式中其所特化的模板形参列表的类模板名；亦即实例化后为当前实例的类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> currently handled exception
</td>
<td> 当前处理的异常
</td>
<td> 【语义】最近激活且仍活跃的异常处理器所处理的异常
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cv-combined type
</td>
<td> cv 合并类型
</td>
<td> 【类型】两个指针类型 T1 和 T2，基于 T1 将 T2 的各级 cv 合并入其中并调整 const 限定
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cv-decomposition
</td>
<td> cv 分解
</td>
<td> 【类型】将类型分解为 cv0 P0 .. cvn U，其中 Pi 为指针或成员指针；cv 分解不唯一，U 可以为指针类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cv-qualification
</td>
<td> cv 限定性
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cv-qualification signature
</td>
<td> cv 限定性签名
</td>
<td> 【类型】最长的 cv 分解中的序列 cv1 .. cvn（不包括顶层的 cv0）；仅在 cv 限定性签名上有区别的类型是相似类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>cv-qualifier</i> <br> cv-qualifier
</td>
<td> <i>cv-限定符</i> <br> cv 限定符
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">const</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">volatile</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> cv-unqualified type
</td>
<td> cv 未限定的类型
</td>
<td> 【类型】没有顶层 cv 限定符的类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> data
</td>
<td> 数据
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> data member
</td>
<td> 数据成员
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> data race
</td>
<td> 数据竞争
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deadlock
</td>
<td> 死锁
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deallocate
</td>
<td> 回收
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deallocation function
</td>
<td> 回收函数
</td>
<td> 【语法】即 <span class="t-c"><span class="mw-geshi text source-text">operator delete</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">operator delete[]</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> decay
</td>
<td> 衰变
</td>
<td> 【语义】当使用右值时对左值进行的三种转换：左值向右值，数组向指针和函数向指针
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>decimal-floating-literal</i>
</td>
<td> <i>十进制浮点字面量</i>
</td>
<td> 【文法】<i>浮点字面量（floating-literal）</i>的一种，包含十进制的整数和小数，<span class="t-c"><span class="mw-geshi text source-text">e</span></span> 和十进制指数部分的十的幂
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>decimal-literal</i>
</td>
<td> <i>十进制字面量</i>
</td>
<td> 【文法】<i>整数字面量</i>的一种，不以 <span class="t-c"><span class="mw-geshi text source-text">​0​</span></span> 开始的十进制数字序列
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> declare
</td>
<td> 声明
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>decl-specifier</i>
</td>
<td> <i>声明说明符</i>
</td>
<td> 【文法】声明式中声明符列表之前的各项，包括类型（包括简单类型，类和枚举的定义体等），<span class="t-c"><span class="mw-geshi text source-text">const</span></span>，<span class="t-c"><span class="mw-geshi text source-text">volatile</span></span>，<span class="t-c"><span class="mw-geshi text source-text">virtual</span></span>，<span class="t-c"><span class="mw-geshi text source-text">explicit</span></span>， <span class="t-c"><span class="mw-geshi text source-text">friend</span></span>，<span class="t-c"><span class="mw-geshi text source-text">typedef</span></span>，<span class="t-c"><span class="mw-geshi text source-text">constexpr</span></span>，<span class="t-c"><span class="mw-geshi text source-text">inline</span></span>， <span class="t-c"><span class="mw-geshi text source-text">static</span></span>，<span class="t-c"><span class="mw-geshi text source-text">thread_local</span></span>，<span class="t-c"><span class="mw-geshi text source-text">extern</span></span>，<span class="t-c"><span class="mw-geshi text source-text">mutable</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>declaraton</i>
</td>
<td> <i>声明式</i>
</td>
<td> 【文法】所有声明式的总范畴，包括<i>块声明式（block-declaration）</i>和命名空间、模板和连接说明等
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> declaration
</td>
<td> 声明式，声明
</td>
<td> 【语法】赋予实体各种性质的语言构造
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> declaration point
</td>
<td> 声明点
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>declaration-statement</i> <br> declaration statement
</td>
<td> <i>声明式语句</i> <br> 声明式语句
</td>
<td> 【文法】作为<i>语句（statement）</i>的<i>块声明式（block-declaration）</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> declarative region
</td>
<td> 声明区
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>declarator</i>
</td>
<td> <i>声明符</i>
</td>
<td> 【文法】<i>声明式</i>中，指定所声明的一个变量或函数的部分；变量的说明符可以带有初始化式，函数参数的说明符可以带有等号的默认 实参
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> decltype specifier <br> <i>decltype-specifier</i>
</td>
<td> decltype 说明符 <br> <i>decltype-说明符</i>
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">decltype</span></span> 关键字跟着带括号的 <span class="t-c"><span class="mw-geshi text source-text">auto</span></span> 或<i>表达式</i>，用以代表表达式的静态类型或类型占位符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> decode
</td>
<td> 解码
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> decomposition declaration
</td>
<td> 分解声明式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> decrement expression
</td>
<td> 自减表达式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> decrement operator
</td>
<td> 自减运算符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deduce
</td>
<td> 推断
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deduced type
</td>
<td> 推断出的类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>deduction-guide</i> <br> deduction guide
</td>
<td> <i>推断指导</i> <br> 推断指导
</td>
<td> 【文法】以函数声明的语法形式为类模板提供进行模板实参推断的指导方案
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default access control
</td>
<td> 默认访问控制
</td>
<td> 【语义】<span class="t-c"><span class="mw-geshi text source-text">class</span></span> 为 <span class="t-c"><span class="mw-geshi text source-text">private</span></span>，<span class="t-c"><span class="mw-geshi text source-text">struct</span></span> 为 <span class="t-c"><span class="mw-geshi text source-text">public</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default argument
</td>
<td> 默认实参
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default argument promotion
</td>
<td> 默认实参提升
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default behavior
</td>
<td> 缺省行为
</td>
<td> 【标准库】由实现提供的可替代函数的缺省实现的行为，应当符合该函数的‘预期行为’
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default constructor
</td>
<td> 默认构造函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default-initialization
</td>
<td> 默认初始化
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default-inserted element
</td>
<td> 默认插入的元素
</td>
<td> 【标准库】容器中通过调用默认构造所插入的元素
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default label
</td>
<td> default 标号
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default member initializer
</td>
<td> 默认成员初始化式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> default memory resource pointer
</td>
<td> 缺省内存资源指针
</td>
<td> 【标准库】某些库组件缺省时使用的内存资源，可以通过 <span class="t-c"><span class="mw-geshi text source-text">set_default_resource</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">get_default_resource</span></span> 管理
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> defaulted
</td>
<td> 预置的
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> defaulted function
</td>
<td> 预置函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deferred function
</td>
<td> 推迟的函数
</td>
<td> 【标准库】以 <span class="t-c"><span class="mw-geshi text source-text">launch::deferred</span></span> 通过 <span class="t-c"><span class="mw-geshi text source-text">async</span></span> 所调用的函数
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> define
</td>
<td> 定义
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> definition
</td>
<td> 定义式，定义
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>defining-type-id</i>
</td>
<td> <i>定义类型标识</i>
</td>
<td> 【文法】用于指定一个类型，允许提供类或枚举的定义体，可以用作别名声明的目标类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>defining-type-specifier</i>
</td>
<td> <i>定义类型说明符</i>
</td>
<td> 【文法】<i>声明说明符</i>或别名声明中用以指定类型的部分，为<i>类型说明符</i>或者类或枚举的定义体
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> delegating constructor
</td>
<td> 委派构造函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> delete
</td>
<td> 删除
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>delete-expression</i>
</td>
<td> <i>delete-表达式</i>
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">delete</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">delete[]</span></span> 运算符的表达式，可以带有全局限定
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> delete operator
</td>
<td> delete 运算符
</td>
<td> 【语法】即 <span class="t-c"><span class="mw-geshi text source-text">delete</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">delete[]</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deleted
</td>
<td> 被删除的
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deleted definition
</td>
<td> 被删除定义
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deleted function
</td>
<td> 被删除函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deleter
</td>
<td> 删除器
</td>
<td> 【标准库】提供给 <span class="t-c"><span class="mw-geshi text source-text">unique_ptr</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">smart_ptr</span></span> 的对象，负责处置或回收资源
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> denormalized value
</td>
<td> 非正规的值
</td>
<td> 【对象】浮点类型，次正规值
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dependency-ordered before
</td>
<td> 按依赖序早于
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dependent member
</td>
<td> 待决的成员
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dependent base class
</td>
<td> 待决的基类
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dependent name
</td>
<td> 待决的名字
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dependent type
</td>
<td> 待决的类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deprecate
</td>
<td> 摒弃，不推荐使用
</td>
<td> 【语义】标记某项语言功能特性或程序库实体因为缺陷或其他原因不再建议使用，一般会提供替代方案
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> deque
</td>
<td> 双端队列
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dereference
</td>
<td> 解引用
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> derivation
</td>
<td> 派生
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> derived class
</td>
<td> 派生类
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> derived-to-base conversion
</td>
<td> 派生类向基类转换
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> destroy
</td>
<td> 销毁
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> destruction
</td>
<td> 销毁
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> destructor
</td>
<td> 析构函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> device
</td>
<td> 设备
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> diagnosable rule
</td>
<td> 可诊断规则
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> diagnostic message
</td>
<td> 诊断消息
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> digraph
</td>
<td> 二连符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> direct base class
</td>
<td> 直接基类
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> direct-initialization
</td>
<td> 直接初始化
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> direct-list-initialization
</td>
<td> 直接列表初始化
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> directed acyclic graph
</td>
<td> 有向无环图
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> directive
</td>
<td> 指令
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>directory-separator</i>
</td>
<td> <i>目录分隔符</i>
</td>
<td> 【文法】路径名中的目录分隔符，斜杠或者操作系统定义的字符
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> disambiguation
</td>
<td> 歧义消解
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> discarded-value expression
</td>
<td> 弃值表达式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> discarded statement
</td>
<td> 弃用语句
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> discrete probability function
</td>
<td> 离散概率函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> disjunction
</td>
<td> 析取
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> distribution
</td>
<td> 分布
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> division operator
</td>
<td> 除法运算符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> do statement
</td>
<td> do 语句
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> domain error
</td>
<td> 值域错误
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>dot</i>
</td>
<td> <i>点</i>
</td>
<td> 【文法】单个点构成的文件名，代表本层目录
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>dot-dot</i>
</td>
<td> <i>点点</i>
</td>
<td> 【文法】两个点构成的文件名，代表上层目录
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dot operator
</td>
<td> 点运算符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dynamic
</td>
<td> 动态的
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dynamic binding
</td>
<td> 动态绑定
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dynamic cast
</td>
<td> 动态强制转换
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dynamic initialization
</td>
<td> 动态初始化
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dynamic storage duration
</td>
<td> 动态存储持续期
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> dynamic type
</td>
<td> 动态类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>elaborated-type-specifier</i>
</td>
<td> <i>详述类型说明符</i>
</td>
<td> 【文法】带有<i>类关键字（class-key）</i>或 <span class="t-c"><span class="mw-geshi text source-text">enum</span></span> 的名字，用于指定类型，具有声明语义
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> element
</td>
<td> 元素
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>empty-declaration</i>
</td>
<td> <i>空声明式</i>
</td>
<td> 【文法】单个分号 <span class="t-c"><span class="mw-geshi text source-text">;</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> empty statement
</td>
<td> 空语句
</td>
<td> 【语法】即省略了<i>表达式</i>的<i>表达式语句</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> encode
</td>
<td> 编码
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>encoding-prefix</i>
</td>
<td> <i>编码前缀</i>
</td>
<td> 【词法】即字符或字符串字面量前面的 <span class="t-c"><span class="mw-geshi text source-text">u</span></span>, <span class="t-c"><span class="mw-geshi text source-text">u8</span></span>, <span class="t-c"><span class="mw-geshi text source-text">U</span></span>, <span class="t-c"><span class="mw-geshi text source-text">L</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> entity
</td>
<td> 实体
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enclosing class
</td>
<td> 外围类
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enclosing namespace
</td>
<td> 外围命名空间
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enclosing scope
</td>
<td> 外围作用域
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>enum-base</i>
</td>
<td> <i>枚举基</i>
</td>
<td> 【文法】冒号和类型，指定枚举类型的底层类型
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>enum-head</i>
</td>
<td> <i>枚举头</i>
</td>
<td> 【文法】枚举关键字 <span class="t-c"><span class="mw-geshi text source-text">enum</span></span>，<span class="t-c"><span class="mw-geshi text source-text">enum class</span></span> 或 <span class="t-c"><span class="mw-geshi text source-text">enum struct</span></span>，特性标注，名字和<i>枚举基</i>，即<i>枚举说明符</i>的花括号前面的部分；可以无名字
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>enum-specifier</i>
</td>
<td> <i>枚举说明符</i>
</td>
<td> 【文法】枚举类型的定义体，包括<i>枚举头</i>和花括号包围的<i>枚举符定义式</i>的列表
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enumeration
</td>
<td> 枚举
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enumeration scope
</td>
<td> 枚举作用域
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enumeration specifier
</td>
<td> 枚举说明符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enumeration type
</td>
<td> 枚举类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> enumerator <br> <i>enumerator</i>
</td>
<td> 枚举符 <br> <i>枚举符</i>
</td>
<td> 【文法】枚举类型的成员，具名常量 <br>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>enumerator-definition</i>
</td>
<td> <i>枚举符定义式</i>
</td>
<td> 【文法】枚举符，可选带有等号和<i>常量表达式</i>作为其初始化式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> equality
</td>
<td> 相等性
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>equality-expression</i>
</td>
<td> <i>相等性表达式</i>
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">==</span></span> 和 <span class="t-c"><span class="mw-geshi text source-text">!=</span></span> 运算符，以及更高优先级的运算符的表达式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> equality operator
</td>
<td> 相等运算符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> equivalence
</td>
<td> 等价
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> error
</td>
<td> 错误，误差
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> escape character
</td>
<td> 转义字符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>escape-sequence</i> <br> escape sequence
</td>
<td> <i>转义序列</i> <br> 转义序列
</td>
<td> 【词法】字符和字符串字面量中，反斜杠和 <span class="t-c"><span class="mw-geshi text source-text">'"?\abfnrtv</span></span> 的转义序列，以及八进制和十六进制转移序列，用以代表一个字符。<i>通用字符名</i>不是转义序列
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> evaluation
</td>
<td> 求值
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> exception
</td>
<td> 异常；例外
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>exception-declaration</i>
</td>
<td> <i>异常声明式</i>
</td>
<td> 【文法】异常处理器的 <span class="t-c"><span class="mw-geshi text source-text">cache</span></span> 子句中声明异常参数的声明式，与函数的<i>形参声明式</i>相同，但没有<i>初始化式</i>部分
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> exception handler
</td>
<td> 异常处理器
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> exception specification
</td>
<td> 异常说明
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>exclusive-or-expression</i>
</td>
<td> <i>异或表达式</i>
</td>
<td> 【文法】<span class="t-c"><span class="mw-geshi text source-text">^</span></span> 和更高优先级的运算符的表达式
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> execute
</td>
<td> 执行
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> execution character set
</td>
<td> 执行字符集
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> execution step
</td>
<td> 执行步骤
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> explicit
</td>
<td> 显式；明确
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>explicit-instantiation</i>
</td>
<td> <i>显式实例化式</i>
</td>
<td> 【文法】关键字 <span class="t-c"><span class="mw-geshi text source-text">template</span></span> 跟着模板特例的声明（而不是定义）；可选带有 <span class="t-c"><span class="mw-geshi text source-text">extern</span></span>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> explicit instantiation
</td>
<td> 显式实例化式
</td>
<td> 【语法】明确要求实例化某个模板特例
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> explicit instantiation declaration
</td>
<td> 显式实例化声明式
</td>
<td> 【语法】以 <span class="t-c"><span class="mw-geshi text source-text">extern</span></span> 声明某个模板特例在其他翻译单元中实例化
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>explicit-specialization</i>
</td>
<td> <i>显式特化式</i>
</td>
<td> 【文法】模板特化式，具有空的<i>模板形参列表</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> explicit specifier
</td>
<td> explicit 说明符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> explicit type conversion
</td>
<td> 显式类型转换
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> explicitly captured
</td>
<td> 显式捕获的
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> explicitly defaulted function
</td>
<td> 显式预置的函数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> exponent
</td>
<td> 指数
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>expr-or-braced-init-list</i>
</td>
<td> <i>表达式或花括号初始化式列表</i>
</td>
<td> 【文法】单个<i>表达式</i>或者<i>花括号初始化式列表</i>，下标，<span class="t-c"><span class="mw-geshi text source-text">return</span></span> 和基于范围的 <span class="t-c"><span class="mw-geshi text source-text">for</span></span> 中可以提供一个表达式或者一个<i>花括号初始化式列表</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>expression</i>
</td>
<td> <i>表达式</i>
</td>
<td> 【文法】代表所有表达式的文法范畴
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>expression-list</i>
</td>
<td> <i>表达式列表</i>
</td>
<td> 【文法】各种函数调用的场合中括号中的列表，文法上为<i>初始化式列表</i>，即<i>初始化式子句</i>（没有等号）的列表
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> <i>expression-statement</i>
</td>
<td> <i>表达式语句</i>
</td>
<td> 【文法】一个（可选的）<i>表达式</i>和一个分号构成的<i>语句</i>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extend namespace definition
</td>
<td> 扩展命名空间定义式
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extended alignment
</td>
<td> 扩充对齐
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extended character set
</td>
<td> 扩展字符集
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extended execution character set
</td>
<td> 扩展执行字符集
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extended integer type
</td>
<td> 扩充整数类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extended signed integer type
</td>
<td> 扩充有符号整数类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extended source character set
</td>
<td> 扩展源字符集
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extended unsigned integer type
</td>
<td> 扩充无符号整数类型
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extension
</td>
<td> 扩展，功能扩展
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> extern specifier
</td>
<td> extern 说明符
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr>
<tr>
<td> external linkage
</td>
<td> 外部连接
</td>
<td>
</td>
<td>
</td>
<td>
</td></tr></table>

<!-- 
NewPP limit report
Preprocessor visited node count: 3088/1000000
Preprocessor generated node count: 3081/1000000
Post‐expand include size: 17942/2097152 bytes
Template argument size: 1891/2097152 bytes
Highest expansion depth: 6/40
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mwiki1-mwiki_zh_:pcache:idhash:8410-0!*!*!*!*!*!zh!* and timestamp 20180818130215 -->
</div>                    <!-- /bodycontent -->
                                        <!-- printfooter -->
                    <div class="printfooter">
                    来自“<a href="https://zh.cppreference.com/mwiki/index.php?title=bilingual_glossary&amp;oldid=51247">https://zh.cppreference.com/mwiki/index.php?title=bilingual_glossary&amp;oldid=51247</a>”                    </div>
                    <!-- /printfooter -->
                                                            <!-- catlinks -->
                    <!-- /catlinks -->
                                                            <div class="visualClear"></div>
                    <!-- debughtml -->
                                        <!-- /debughtml -->
                </div>
                <!-- /bodyContent -->
            </div>
        </div>
        <!-- /content -->
        <!-- footer -->
        <div id="cpp-footer-base" class="noprint">
            <div id="footer">
                        <div id="cpp-navigation">
            <h5>导航</h5>
            <ul><li><a href="https://zh.cppreference.com/w/bilingual_glossary">Online version</a></li><li>Offline version retrieved 2019-08-25 10:54.</li></ul></div>
                        <ul id="footer-info">
                                    <li id="footer-info-lastmod"> 本页面最后修改于2017年11月28日 (星期二) 00:40。</li>
                                    <li id="footer-info-viewcount">此页面已被浏览过3,222次。</li>
                            </ul>
                    </div>
        </div>
        <!-- /footer -->
        <script>if(window.mw){
mw.loader.state({"site":"loading","user":"missing","user.groups":"ready"});
}</script>
<script src="../common/skin_scripts.js"></script>
<script>if(window.mw){
mw.loader.load(["mediawiki.action.view.postEdit","mediawiki.user","mediawiki.page.ready","mediawiki.searchSuggest","mediawiki.hidpi","ext.gadget.MathJax","ext.gadget.ColiruCompiler"], null, true);
}</script>
<script src="../common/site_scripts.js"></script>
<script type="text/javascript">
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-2828341-1']);
_gaq.push(['_setDomainName', 'cppreference.com']);
_gaq.push(['_trackPageview']);
</script><!-- Served in 0.075 secs. -->
	</body>
<!-- Cached 20180819042442 -->
</html>